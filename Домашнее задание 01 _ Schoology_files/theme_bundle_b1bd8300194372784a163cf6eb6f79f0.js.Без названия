
Drupal.theme.prototype.popupButton = function(title, id) {
  return '<span><input type="button" value="'+ title +'" id="'+ id +'" /></span>';
};

Drupal.theme.prototype.popupLoading = function() {
  var loading = '<div id="popups-loading"><div>';
  loading += Drupal.t('Loading...');
  loading += '</div></div>';
  return loading;
};

Drupal.theme.prototype.popupDialog = function(popupId, title, body, buttons) { 
  var template = Drupal.theme('popupTemplate', popupId);
  if(buttons){
    body = '<div class="popups-body-inner-has-buttons">' + body + '</div>';
  }
  var popups = template.replace('%title', title).replace('%body', body);
  
  var themedButtons = '';
  if (buttons) {
    jQuery.each(buttons, function (id, button) {
      themedButtons += Drupal.theme('popupButton', button.title, id);
    });
    themedButtons = '<div class="popups-buttons-inner">' + themedButtons + '</div>';
  }  
  popups = popups.replace('%buttons', themedButtons);  
  return popups;
};

/**
 * Similar to drupal_attributes
 *
 * @param object attrs
 */
Drupal.attributes =
Drupal.theme.prototype.attributes = function(attrs){
  var ret = '';
  $.each(attrs, function(k, v){
    ret += ' ' + k + '="' + Drupal.checkPlain(v) +'"';
  });
  return $.trim(ret);
};

/**
 * Similar to Drupal's l()
 *
 * @param string text
 * @param string path
 * @param object opts
 */
Drupal.l =
Drupal.theme.prototype.l = function(text, path, opts){
  if(typeof opts == 'undefined'){
    var opts = {};
  }
  var defaults = {
    attributes: {},
    html: false
  };
  opts = $.extend(defaults, opts);
  
  return '<a href="' + path + '"' + Drupal.attributes(opts.attributes) + '>' + (opts.html ? text : Drupal.checkPlain(text))  + '</a>';
};

/**
 * Return a jquery object with the tipsy plugin bound.
 *
 * @param string content  the content to show in the tipsy
 * @param object opts
 *    string text        the text to go inside the element that triggers the tipsy
 *    string gravity     
 *    object attributes  standard Drupal.attributes
 */
Drupal.theme.infotip = function(content, opts){
  if(typeof opts == 'undefined'){
    var opts = {};
  }
  var defaults = {
    text: '',
    gravity: 's',
    attributes: {
      'class': ''
    }
  };
  opts = $.extend(defaults, opts);

  var el = '<span ' + Drupal.attributes(opts.attributes) + '>' + opts.text + '</span>';
  var infotipObj = $(el);
  infotipObj.tipsy({
    html: true,
    gravity: opts.gravity,
    title: function(){
      return content;
    }
  });

  return infotipObj;
};

/*
 * Return Markup for action links
 */
Drupal.theme.sActionLinks = function(links, opts){
  if(typeof opts == undefined){
    var opts = {};
  }
  
  if(typeof links != 'object' && links.length == 0){
    return '';
  }
  
  var defaults = {
    wrapperId : '',
    ulId : '',
    btnId : '',
    btnClass : '',
    ulClass : '',
    wrapperClass : '',
    size : 'regular',
    text : '',
    isAngular : true
  };
  opts = $.extend(defaults, opts);
  var output = '';
  output += '<div class="' + (opts.isAngular ? 's-action-link' : '') + ' action-links-wrapper action-links-wrapper-' + opts.size + ' ' + opts.wrapperClass + '">';
  output += '<div tabindex="0" role="button" class="action-links-unfold" id="' + opts.btnId + '">';
  output += '<span class="action-links-unfold-text"><span class="visually-hidden">' + Drupal.t('Click to toggle options.') + '</span></span>';
  output += '</div>';
  output += '<ul class="action-links">';
  $.each(links, function(k, v){
    output += v;
  });
  output += '</ul>';
  output += '</div>'; 
  return output;
}

Drupal.theme.sCommonAngularDeletePopup = function(){
  return {
    title : Drupal.t('Delete'),
    body : Drupal.t('Are you sure you want to delete this?'),
    confirm : {
      text : Drupal.t('Delete')
    },
    cancel : {
      text : Drupal.t('Cancel')
    }
  };
}

/**
 * Register an element for popups with the provided options.
 *
 * @param string/object el  selector or jquery object
 * @param object opts       popups options
 */
Drupal.popup = function(el, opts){
  var elObj = $(el)
  elObj.not('.popups-processed').addClass('popups-processed').click(function(e){
    e.preventDefault();
    return Popups.clickPopupElement(this, opts);
  });

  return elObj;
};

Drupal.behaviors.schoologyTheme = function(context){
  $('.popups-body textarea:not(.schoologyTheme-processed)').addClass('schoologyTheme-processed').each(function(){
    var ta = $(this);
    ta.focus(function(){
      ta.addClass('popups-textarea-focus');
	  popup = Popups.activePopup();
		if(popup != null)
				Popups.resizeAndCenter(popup);
    });
  });
};

Drupal.theme.sAjaxLoader = function(options){
  var defaultOpts = {
    asString : false,
    imgId : false
  };
  var opts = $.extend( {}, $.fn.sActionLinks.defaults, options);
  var ajaxLoader = $('<img />').attr('src','/sites/all/themes/schoology_theme/images/ajax-loader.gif').addClass('ajax-loader');
  
  if(opts.imgId){
    ajaxLoader.attr('id', opts.imgId);
  }
  
  if(opts.asString){
    return ajaxLoader[0].outerHTML;
  }
  return ajaxLoader;
}

Drupal.theme.sAjaxMessage = function(message, msgClass){
 var msg = '<div class="messages ' + msgClass + '">\n\
          <div class="messages-close-btn" style="">x</div>\n\
          <div class="messages-container">\n\
            <table role="presentation"><tbody><tr>\n\
               <td><div class="messages-icon">&nbsp;</div></td>\n\
               <td><div class="message-text">' + message + '</div></td>\n\
            </tr></tbody></table>\n\
          </div>\n\
        </div>';
  
  return msg;
}

Drupal.theme.s_course_no_members_overlay = function(course_nid, showNoMembers, showNoTags){
  var output = '';

  // default show no tags to false
  if(typeof showNoTags == 'undefined'){
    showNoTags = false;
  }

  // Default show no members to true
  if(typeof showNoMembers == 'undefined'){
    showNoMembers = true;
  }

  output += '<div class="s-js-no-members-overlay no-members-overlay hidden">';
  if(showNoMembers){
    output += '<div class="no-members-message">';
      output += '<span class="inline-icon medium students mono"></span>';
      output += Drupal.t('Currently there are no <a href="!members_link">members</a> in this course', {'!members_link': '/course/' + course_nid + '/members'});
    output += '</div>';
  }
  if(showNoTags && !showNoMembers){
    output += '<div class="no-tags-message">';
      output += '<span class="inline-icon medium tags mono"></span>';
      output += Drupal.t('There are no learning objectives aligned in this course');
    output += '</div>';
  }
  output += '</div>';

  return output;
};
;Drupal.theme.s_grades_grading_rubrics_launch_btn = function(realm, realm_id, itemNid, rubricId, isGradeItem, text, isResource, is_action_edit_link, isResourceMaterial, isReadOnly, wrapperClass, isDistrictMasteryEnabled){
  if(angular.isUndefined(text) || text == null){
    text = '';
  }
  if(angular.isUndefined(isGradeItem) || isGradeItem == null){
    isGradeItem = false;
  }
  if(angular.isUndefined(isResource) || isResource == null){
	  isResource = false;
  }
  if(angular.isUndefined(isResourceMaterial) || isResourceMaterial == null){
    isResourceMaterial = false;
  }
  if(angular.isUndefined(isReadOnly) || isReadOnly == null){
    isReadOnly = false;
  }
  if(angular.isUndefined(wrapperClass) || wrapperClass == null){
    wrapperClass = false;
  }
  if(angular.isUndefined(isDistrictMasteryEnabled) || isDistrictMasteryEnabled == null){
    isDistrictMasteryEnabled = false;
  }

  var directiveAttrs = 'realm-id="' + realm_id + '"';
  directiveAttrs += ' realm="' + realm + '"';
  if(angular.isDefined(rubricId) && rubricId != null){
    directiveAttrs += ' rubric-id="' + rubricId + '"';
  }

  if(angular.isDefined(itemNid) && itemNid != null){
    directiveAttrs += ' item-nid="' + itemNid + '"';
  }

  directiveAttrs += ' is-grade-item="' + (isGradeItem == true ? 'true' : 'false') + '"';
  directiveAttrs += ' is-resource="' + (isResource == true ? 'true' : 'false') + '"';
  directiveAttrs += ' is-resource-material="' + (isResourceMaterial == true ? 'true' : 'false') + '"';
  directiveAttrs += ' is-read-only="' + (isReadOnly == true ? 'true' : 'false') + '"';
  directiveAttrs += ' wrapper-class="' + wrapperClass + '"';
  directiveAttrs += ' is-district-mastery-enabled="' + isDistrictMasteryEnabled + '"';

  var output = '';
  var action_edit_link_class = is_action_edit_link ? 'class="action-edit" ' : '';
  var title_class = !is_action_edit_link ? 'item-title ' : '';
  var clickable_class = (!is_action_edit_link && itemNid != 'e') ? 'clickable ' : '';
  output += '<div ng:controller="s_grading_rubric_form_launch"' + action_edit_link_class + '>';
  output += '<span id="grading-rubric-launch-btn" class="grading-rubric-launch-icon grading-rubric-launch ' + title_class + clickable_class + '" ' + directiveAttrs + '>' + text + '</span>';
  output += '</div>';
  return output;
}

Drupal.theme.s_grades_grading_rubric_edit = function(isGradeItem, isResource, isReadOnly, isDistrictMasteryEnabled){
  var output = '';
  output += '<div class="s-slider s-grading-rubric-edit-slider s-grading-rubric" id="grading-rubric-edit-slider" ng:controller="s_grading_rubric_edit" ng:class="rubricBodyClass()" ng:init="isGradeItem=' + isGradeItem + '; isResource=' + isResource + '">';
    output += '<div class="controls">';
      output += '<span class="control-btn close-btn" ng:click="changeState(\'closed\')"></span>';
      output += '<span class="control-btn slide-btn" ng:click="changeState(\'slide-closed\')"></span>';
    output += '</div>';
    output += '<div class="left-column">';
      // Treat the one we are editing differently than the ones we have saved
      output += '<div class="rubric-item-custom" ng:class="{active : activeRubricId==\'e\'}" ng:click="rubricItemClick($event, \'e\')">'
        output += '<span class="title"><span></span>{{defaultTitle}}</span>';
      output += '</div>';
      output += '<div class="rubric-list-header">';
        var actionLinks = [
          '<li ng:class="{active : rubricSort==sortOpt.field}" ng-repeat="sortOpt in rubricSortOptions" ng-click="setRubricSort(sortOpt)">{{sortOpt.title}}</li>'
        ];
        output += Drupal.theme.sActionLinks(actionLinks, {size : 'junior', wrapperClass : 'rubric-sort-opts'});
        output += '<span>' + Drupal.t('Edit Rubrics') + '</span>';
      output += '</div>';
      output += '<ul class="rubric-list">';
        // The ones we have saved live in a different object
        output += '<li class="rubric-item" ng:class="getSaveRubricClass(savedRubric.id)" ng:repeat="savedRubric in savedRubricsList | orderBy:rubricSort" ng:click="rubricItemClick($event, savedRubric.id)">';
          output += '<span class="title"><span></span>{{savedRubric.title}}</span>';
          output += '<div class="meta">';
            output += '<span class="num-assignments s-infotip" item-info="savedRubric.num_assigned_gi" text="savedRubric.num_assigned_infotip" enabled="true" gravity="\'s\'"><span></span>{{itemInfo}}</span> &middot; <span class="total-points">{{savedRubric.total_points}}' + Drupal.t('pts') + '</span>';
          output += '</div>';
        output += '</li>';
      output += '</ul>';
    output += '</div>';
    output += '<div class="right-column">';
      output += '<div ui-if="isEditable()" class="error messages no-bg" ng:show="rubrics[activeRubricId].num_assigned_gi > 0">' + Drupal.t('Note : Rubric is used by other assignments. Any changes here will be updated across all.') + '</div>';
      output += '<div ui-if="isEditable()" class="error messages no-bg" ng:show="rubrics[activeRubricId].num_printed_gi > 0">' + Drupal.t('Note : This test has been printed. If you edit the test or associated rubrics it will invalidate the previously printed tests.') +'</div>';
      output += '<div class="error messages no-bg" ng:show="hasTitleError || hasNumericPointsError()">{{errorMessage}}</div>';
      output += '<div class="error messages no-bg" ng:show="hasCriteriaError">{{criteriaErrorMessage}}</div>';
      output += '<div ui-if="isEditable()" class="save-for-reuse">';
        output += '<input ng-disabled="!isEditable()" type="text" ng:class="{error : hasTitleError}" class="s-prefill" prefill-text="' + Drupal.t('Rubric Title') + '" id="rubric-title-input" type="text" ng:model="rubrics[activeRubricId].title"/>';
                if(undefined == Drupal.settings.point_based_grading_scale_options) {
                  Drupal.settings.point_based_grading_scale_options = '';
                }
        output += '<span ui-if="isEditable()" >' + Drupal.settings.point_based_grading_scale_options + '</span>' || "";
        output += '<span class="form-required rubric-title-required">*</span>';
      output += '</div>';
      output += '<div class="rubric-scroll s-scroll" s-scroll><table class="rubric-table">';
        output += '<thead>';
          output += '<tr class="header-row">';
            output += '<th ng:hide="!isEditable()" class="sort-header " data-noresize></th>';
            output += '<th scope="col" class="criteria-header header ">';
              output += '<span>' + Drupal.t('Criteria') + '</span>';
            output += '</th>';
            output += '<th scope="col" class="ratings-header header "><span>' + Drupal.t('Grading Scale') + '</span></th>';
            var pts_header_copy = (isReadOnly ? Drupal.t('Points') : Drupal.t('Pts'));
            output += '<th scope="col" class="points-header header " data-noresize><abbr title="' + Drupal.t('Points') + '">' + pts_header_copy + '</abbr></th>';
          output += '</tr>';
        output += '</thead>';
        output += '<tbody>';
        output += '</tbody>';
        output += '<tbody ui-sortable="{handle : \'.sort-handle\'}" ng:model="rubrics[activeRubricId].rows">';
          output += '<tr class="rubric-row" ng:repeat="(i, row) in rubrics[activeRubricId].rows">';
            output += '<td ng:hide="!isEditable()" class="sort-handle "><span></span></td>';
            output += '<td  class="rubric-row-title ">';
              output += '<div class="rubric-row-relative">';
                output += '<input ui-if="isEditable() && !row.is_published" class="s-prefill input-top" type="text" prefill-text="' + Drupal.t('Add Title') + '" ng:model="row.title" ng:class="{error : errorCriteriaRows[i]}" ui-event="{ blur : \'fillSelectedBox()\' }"/>';
                output += '<span ui-if="!isEditable() || row.is_published" class="input-top">{{row.title}}</span>';
                output += '<div class="rating-item-overflow-y">';
                  output += '<textarea ui-if="isEditable() && !row.is_published" prefill-text="' + Drupal.t('Add Description') + '" class="s-prefill input-bottom text-autogrow" ng:model="row.description"></textarea>';
                  output += '<p ui-if="!isEditable() || row.is_published" class="input-bottom">{{row.description}}</p>';
                output += '</div>';
              output += '</div>';
            output += '</td>';
            output += '<td class="rubric-row-rating"><table class="rating-table"><tbody><tr>';
              output += '<td class="rating-wrapper" ng:repeat="(j, column) in row.columns">';
                output += '<div class="rating-item">';
                  output += '<span ui-if="isEditable()" class="s-infotip" selector="\'.add-column-btn\'" gravity="\'s\'" text="\'' + Drupal.t('Add Grading Scale Cell') + '\'">';
                    output += '<span class="add-column-btn left" ng:click="$parent.addColumn($parent.i, $parent.j, -1)"></span>';
                  output += '</span>';
                  output += '<input ui-if="isEditable()" class="input-top" type="text" ui-event="{ blur : \'sortColumns(i)\' }" ng:model="column.pts" ng:change="rowPointsChange(i)" ng:class="{error : cellHasError(i, j)}"/>';
                  output += '<span ui-if="!isEditable()" class="input-top">{{column.pts}}</span>';
                  output += '<span ui-if="isEditable()" class="s-infotip" selector="\'.add-column-btn\'" gravity="\'se\'" text="\'' + Drupal.t('Add Grading Scale Cell') + '\'">';
                    output += '<span class="add-column-btn right" ng:click="$parent.addColumn($parent.i, $parent.j, -1)"></span>';
                  output += "</span >";
                  output += '<span ui-if="isEditable()" class="delete-btn" ng:click="removeColumn(i,j)"></span>';
                  output += '<div class="rating-item-overflow-y">';
                    output += '<textarea ui-if="isEditable()" class="input-bottom text-autogrow" ng:model="column.description"></textarea>';
                    output += '<p ui-if="!isEditable()" class="input-bottom">{{column.description}}</p>';
                  output += '</div>';
                output += '</div>';
              output += '</td>';
            output += '</tr></tbody></table></td>';
            output += '<td class="rubric-row-pts ">';
              output += '<span>{{row.max_points}}</span>';
              output += '<span ui-if="isEditable()" class="s-infotip" gravity="\'e\'" text="\'' + Drupal.t('Delete Criteria Row') + '\'">';
                output += '<span class="delete-btn" ng:click="$parent.removeRow($parent.i)"></span>';
              output += '</span>';
            output += '</td>';
          output += '</tr>';
        output += '</tbody>';
      output += '</table></div>';
    output += '</div>';
    output += '<div class="bottom-ctrls-wrapper">';
      output += '<span class="total-pts">' + Drupal.t('TOTAL POINTS') + ': {{rubrics[activeRubricId].total_points}}</span>';
      output += '<span ui-if="isEditable()">';
        output += '<div class="rubric-editor-add-criteria" ng:click="addRowClick()">';
          output += '<span class="add-criteria-text">' + Drupal.t('Criteria') + '</span>';
        output += '</div>';
      output += '</span>';
      if (!isDistrictMasteryEnabled) {
        output += '<span ui-if="isEditable()" ng:class="{hidden: alignmentHidden()}">';
          output += '<div class="rubric-editor-add-objectives" ng:click="addAlignmentRowClick()" >';
            output += '<span class="add-criteria-text">' + Drupal.t('Learning Objectives') + '</span>';
          output += '</div>';
        output += '</span>';
      }
    output += '</div>';
    output += '<div ui-if="isEditable()" class="large-submit-buttons">';
      output += '<span ui-if="isEditable()" ng:click="rubricFormSubmit(false)" class="btn cancel">' + Drupal.t('Cancel') + '</span>';
      output += '<button ui-if="isEditable()" ng:disabled="saving || !isEditable()" ng:click="rubricFormSubmit(true)" class="btn submit" ng-class="{\'disabled\': !isEditable()}">{{submitButtonText()}}</button>';
    output += '</div>';
  output += '</div>';
  if (isReadOnly){
    output = '<div class="readonly">' + output + "</div>";
  }
  return output;
};

/**
 * @param {boolean} isReadOnly
 * @param {boolean} isDistrictMasteryEnabled
 * @param {boolean} isPrintingRubricsEnabledForUser
 * @returns {string}
 */
Drupal.theme.s_grades_grading_rubrics_block = function(isReadOnly, isDistrictMasteryEnabled, isPrintingRubricsEnabledForUser) {
  var output = '<div ng:controller="s_grades_grading_rubrics_block">';
    output += '<ul id="rubrics-block-right-list">';
      output += '<li ng-repeat="rubricItem in rubrics">';
        var editLink = '<li class="rubric-edit action-edit">' + Drupal.theme.s_grades_grading_rubrics_launch_btn('{{realm}}', '{{realmId}}', null, '{{rubricItem.id}}', false, Drupal.t('Edit'), null, null,null, null, null, isDistrictMasteryEnabled) + '</li>';
        var copyToCourseLink = '<li class="rubric-edit action-copy"><a class="copy-rubric" href="/grading_scale/rubric/{{rubricItem.id}}/copy">' + Drupal.t('Copy To Course') + '</a></li>';
        var deleteLink = '<li class="rubric-delete action-delete">';
        // Can delete the rubric
        deleteLink += '<span ui-if="rubricItem.num_assigned_gi == 0" class="s-popup popups-small" client-popup="1" client-popup-handler="sCommonAngularDeletePopup" client-popup-text="' + Drupal.t('Are you sure you want to delete this rubric?') + '" client-popup-arg="{{rubricItem.id}}" client-popup-submit="gradingRubricDelete">' + Drupal.t('Delete') + '</span>';
        // Cannot delete the rubric
        deleteLink += '<span class="s-infotip" enabled="1" gravity="\'ne\'" text="\'' + Drupal.t('This rubric is in use') + '\'" ui-if="rubricItem.num_assigned_gi > 0">' + Drupal.t('Delete') + '</span>';
        deleteLink += '</li>';
        var saveToResourcesLink = '<li class="rubric-save action-library-save">' + Drupal.l(Drupal.t('Save to Resources'), '/grade_setup/{{realm}}/{{realmId}}/rubric/{{rubricItem.id}}/save', { "attributes": { "class" : "save-rubric" }}) + '</li>';
        var actionLinks = [
          editLink,
          copyToCourseLink,
          deleteLink,
          saveToResourcesLink
        ];
        // TODO: PE-58978 remove FF check
        if (isPrintingRubricsEnabledForUser) {
          var printRubricLink = '<li class="action-print">' + Drupal.l(Drupal.t('Print Rubric'), '/grading-scales/{{rubricItem.id}}/print-page', { attributes: { target: '_blank' } }) + '</li>';
          actionLinks.push(printRubricLink);
        }
      	output += Drupal.theme.sActionLinks(actionLinks, {size : 'junior', wrapperClass : 'aligned-right'});
        output += '<div class="rubric-info">';
          output += '<span class="title">' + Drupal.theme.s_grades_grading_rubrics_launch_btn('{{realm}}', '{{realmId}}', null, '{{rubricItem.id}}', false, '{{rubricItem.title}}', null, null, null, isReadOnly, null, isDistrictMasteryEnabled) + '</span>';
          output += '<div class="meta">';
            output += '<span class="num-assignments s-infotip" item-info="rubricItem.num_assigned_gi" text="rubricItem.num_assigned_infotip" enabled="true" gravity="\'s\'"><span></span>{{itemInfo}}</span> &middot; <span class="total-points">{{rubricItem.total_points}}' + Drupal.t('pts') + '</span>';
          output += '</div>';
        output += '</div>';
      output += '</li>';
    output += '</div>';
  output += '</div>';
  return output;
}

/*
 * Directive to compile and launch the s_grades_rubric_grading
 */
Drupal.theme.s_grades_rubric_grading_launch_btn = function(rubric_id, enrollment_id, item_id, dispGrade, editable, isComponent, submissionId, totalRubricPoints, textOnly){
  if (rubric_id === 'reactRubricScoreInput') {
    return '<span class="grading-rubric-grading-launch" is-react-component="true"></span>';
  }

  if(angular.isUndefined(isComponent) || isComponent == null){
    isComponent = false;
  }
  if(angular.isUndefined(submissionId) || submissionId == null){
    submissionId = false;
  }
  var attrs = 'rubric-id="' + rubric_id
    + '" enrollment-id="' + enrollment_id
    + '" item-id="' + item_id
    + '" editable="' + editable
    + '" is-component="' + isComponent
    + '" submission-id="' + submissionId
    + '" total-rubric-points="' + totalRubricPoints
    + '" text-only="' + textOnly + '"';
  var output = '';
  if (isComponent) {
    output += '<div id="question-points-total-' + item_id + '" class="question-points-total"></div>';
  }
  output += '<span tabindex="0" role="button" class="grading-rubric-launch-icon grading-rubric-grading-launch" ' + attrs + ' aria-label="Click to launch rubrics popup">'
   output += '<img src="/sites/all/themes/schoology_theme/images/icons_sprite_new.png" class="grading-rubric-image" alt="Rubric icon. Opens a dialog.">';
   output += '<div class="rubric-fake-grade-disp">' + dispGrade + '</div>';
   output += '<span class="visually-hidden">' + Drupal.t('Click to launch rubrics popup.') + '</span>';
  output += '</span>';
  if (isComponent) {
    output += '<span id="rubric-total-points-' + item_id + '" class="rubric-total-points" value="' + totalRubricPoints + '"> /' + totalRubricPoints + '</span>';
  }
  return output;
}

Drupal.theme.s_grades_rubric_grading = function(){
  var output = '';
  output += '<div s-js-tab="trapTabKey" class="s-slider s-js-manage-focus rubric-grades-edit" ng:class="rubricGradesBodyClass()" ng:controller="grading_rubric_edit_grades" id="grading-rubric-edit-grades-slider" role="dialog" aria-label="' + Drupal.t('Rubrics Grade Dialog') + '" aria-describedby="grading-rubric-info">';
    output += '<div role="document">';
      output += '<div id="grading-rubric-info" class="visually-hidden" aria-hidden="true">';
        output += '<p>' + Drupal.t('This dialog details the grading criteria for the associated assignment and displays the points awarded for each grading criteria.') + '</p>'
      output += '</div>';
      output += '<div class="controls">';
        output += '<span role="button" tabindex="0" class="control-btn close-btn" ng:click="changeState(\'closed\')">' + '<span class="visually-hidden">' + Drupal.t('Close') + '</span>' + '</span>';
        output += '<span role="button" tabindex="0" class="slide-btn" ng:click="changeState(\'slide-closed\')">';
          output += '<span ui-if="getState() == \'opened\'" class="visually-hidden">' + Drupal.t('Slide Close') + '</span>';
          output += '<span ui-if="getState() == \'slide-closed\'" class="visually-hidden">' + Drupal.t('Slide Open') + '</span>';
        output += '</span>';
        output += '<span role="button" tabindex="0" class="minimize-btn" ng:click="minimize()">';
          output += '<span ui-if="!isMinimized()" class="visually-hidden">' + Drupal.t('Minimize') + '</span>';
          output += '<span ui-if="isMinimized()" class="visually-hidden">' + Drupal.t('Maximize') + '</span>';
        output += '</span>';
      output += '</div>';


      output += '<div ui-if="canEditGrade()" class="rubric-comment-bubble-holder editable">';
        output += '<div ng:repeat="rubricRow in rubric.rows" id="comment-area-{{rubricRow.id}}" ng:show="activeCommentBubbleRowId == rubricRow.id" class="inline-popup-wrapper"><span class="arrow-top"></span>';
          output += '<textarea prefill-text="' + Drupal.t('Add Comment') + '" maxlength="4096" class="s-prefill" ng:model="gradeInfo[rubricRow.id].comment"></textarea>';
        output += '</div>';
      output += '</div>';
      if (angular.isDefined(Drupal.theme.s_common_enrollment_chooser) && angular.isDefined(Drupal.settings.s_realm_info)) {
        output += '<div ui-if="canEditGrade() && !isComponent" class="top" >';
          output += Drupal.theme.s_common_enrollment_chooser('course', Drupal.settings.s_realm_info.realm_id);
        output += '</div>';
      }

      output += '<div class="right-column">';
        output += '<div class="rubric-grades-edit-top">';
        output += '</div>';
        output += '<table class="rubric-table rubric-grading-table" >';
          output += '<thead>';
            output += '<tr class="header-row">';
              output += '<th scope="col" class="criteria-header header">' + Drupal.t('Criteria') + '</th>';
              output += '<th scope="col" class="ratings-header header">' + Drupal.t('Rating') + '</th>';
              output += '<th scope="col" class="points-header header"><abbr title="' + Drupal.t('Points') + '">' + Drupal.t('Pts') + '</abbr></th>';
            output += '</tr>';
          output += '</thead>';
          output += '<tbody>';
            output += '<tr class="rubric-row" ng:repeat="rubricRow in rubric.rows">';
              // CRITERIA CELL
              output += '<th scope="row" class="rubric-row-title">';
                output += '<span class="input-top">{{rubricRow.title}}</span>';
                output += '<p class="input-bottom">{{rubricRow.description}}</p>';
              output += '</th>';
              // RATINGS CELL
              output += '<td class="rubric-row-rating">';
                output += '<table class="rating-table" role="presentation">';
                  output += '<tbody>';
                    output += '<tr>';
                      output += '<td class="rating-wrapper" ng:repeat="rubricColumn in rubricRow.columns" ng:class="{selected : rubricColumn.pts == gradeInfo[rubricRow.id].grade}" ng:click="!canEditGrade() || ratingSelect(rubricRow.id, rubricColumn.pts)">';
                        output += '<div ui-if="rubricColumn.pts == gradeInfo[rubricRow.id].grade">';
                          output += '<span class="visually-hidden">' + Drupal.t('This item is selected.') + '</span>';
                        output += '</div>';
                        output += '<div class="rating-item">';
                          output += '<span class="input-top">{{rubricColumn.pts}}</span>';
                          output += '<p class="input-bottom">{{rubricColumn.description}}</p>';
                        output += '</div>';
                      output += '</td>';
                    output += '</tr>';
                  output += '</tbody>';
                output += '</table>';
              output += '</td>';
              // PTS CELL
              output += '<td class="rubric-row-pts">';
                output += '<div class="rubric-row-pts-wrapper" id="rubric-grading-row-area-{{rubricRow.id}}">';
                    //edit grade
                    output += '<input ui-if="canEditGrade()" class="criteria-grade editable" type="text" ng:model="gradeInfo[rubricRow.id].grade"/>';
                    output += '<span ui-if="canEditGrade()" class="active-comment-bubble editable" ng:click="setActiveCommentBubble(rubricRow.id, $event)" ng:class="getBubbleIconClass(rubricRow.id)"></span>';
                    //can not edit grades
                    output += '<div ui-if="!canEditGrade()" ng:class="getBubbleIconClass(rubricRow.id)">';
                      output += '<span class="criteria-grade s-infotip" item-info="gradeInfo[rubricRow.id]" text="gradeInfo[rubricRow.id].comment" enabled="true" gravity="\'ne\'">{{itemInfo.grade}}</span>';
                    output += '</div>';
                    output += '<p ui-if="!canEditGrade() && gradeInfo[rubricRow.id].comment.length > 0" class="visually-hidden">';
                      output += '<span>' + Drupal.t('Comments: ') + '{{gradeInfo[rubricRow.id].comment}}</span>';
                    output += '</p>';
                output += '</div>';
              output += '</td>';
            output += '</tr>';
          output += '</tbody>';
        output += '</table>';
      output += '</div>';
      output += '<div class="bottom">';
        if (angular.isDefined(Drupal.settings.s_realm_info)) {
          output += '<a ui-if="canEditGrade()" class = "editable" href="/course/' + Drupal.settings.s_realm_info.realm_id + '/gradesetup' + '" target="_blank">' + Drupal.t('Manage Rubrics') + '</a>';
        }
        output += '<p class="total-points" ng:class="{\'grade-overridden\' : gradeIsOverridden()}">';
          output += '<span class="total-points-text"><abbr title="' + Drupal.t("Total Points") + '">' + Drupal.t('Total pts: ') + '</abbr></span>';
          output += '<span class="assigned-grades-total" ng:click="toggleOverrideEdit()" ng:show="!overrideEditActive || readOnly">';
            output += '<span>{{totalPoints()}}</span>';
          output += '</span>';
          output += '<span ui-if="canEditGrade()" ng:show="overrideEditActive" class="override-score">';
            output += '<input type="text" id="rubric-score-override" hidden-input hidden-input-sync="overrideEditActive" hidden-input-update="toggleOverrideEdit()" type="text" hidden-input-val="overrideInfo.grade" ng:model="hiddenInputVal"/>';
          output += '</span>';
          output += '/{{rubric.total_points}}';
        output += '</p>';
        output += '<span ui-if="canEditGrade()" class="override-lock" ng:show="gradeIsOverridden()" ng:click="clearGradeOverride()">' + Drupal.t('clear override') + '</span>';
        output += '<span ui-if="canEditGrade()" class="override-lock override-lock-error-message" ng:show="gradeOverrideError()">' + Drupal.t('To override the rubric score you must enter a number') + '</span>';
      output += '</div>';
      output += '<div ui-if="canEditGrade()" class="submit-buttons editable">';
        output += '<button ng:click="rubricGradeFormSubmit(true)" class="submit-btn">' + Drupal.t('Save') + '</button>';
        output += '<span ng:click="rubricGradeFormSubmit(false)" class="cancel-btn">' + Drupal.t('Cancel') + '</span>';
      output += '</div>';
    output += '</div>';
  output += '</div>';
  return output;
}
;// Controller that acts as interface between jquery form and angular rubric selector
sAngular.addController('s_grading_rubric_form_launch', ['$scope', 'gradingRubrics', function($scope, gradingRubrics){
  // A new rubric has been made and saved
  $scope.$on('gradingRubricSelect', function(event, rubric){
    if(typeof sGradeItemSelectScaleChange == 'undefined'){
      return;
    }

    var scaleSelectorWrapper = $('.grading-scale-select-grouping.is-launch-wrapper');
    var selectorObj = $('select', scaleSelectorWrapper);
    var existingRubric = $('option[value="' + rubric.id + '"]', selectorObj);
    if(existingRubric.length){
      var optionList = $('option', selectorObj);
      for(var i = 0; i < optionList.length; i++){
        var optionObj = $(optionList[i]);
        var optionVal = optionObj.attr('value');
        if(optionVal == rubric.id){
          selectorObj.selectmenu('value', i);
          break;
        }
      }
      sGradeItemSelectScaleChange(selectorObj.parents('form'), optionObj, false);
    }
    else {
      Drupal.settings.s_grading_rubrics[rubric.id] = {id : rubric.id, total_points : rubric.total_points};
      var rubricTitle = rubric.title;
      var addRubricOption = $('.select-custom-rubric-title');
      // change title and ID of "Create New" to newly created rubric
      addRubricOption.text(rubricTitle);
      $('[value=r]', selectorObj).val(rubric.id);
      addRubricOption.val(rubric.id);
      addRubricOption.addClass('rubric-title-' + rubric.id);
      $('#edit-max-points').val(rubric.total_points);
      Drupal.settings.s_grading_rubrics[rubric.id] = rubric.total_points;
      sGradeItemSelectScaleChange(selectorObj.parents('form'), addRubricOption, false);
    }
  });

  // An existing rubric has been updated
  $scope.$on('gradingRubricSelectModify', function(event, rubric){
    // Update all the titles associated with this rubric
    if(angular.isDefined(Drupal.settings.s_grading_rubrics)){
      $('.rubric-title-' + rubric.id + ',.title .grading-rubric-launch[rubric-id="' + rubric.id + '"]').text(rubric.title);
      $('#edit-max-points, .total-points').val(rubric.total_points);
      Drupal.settings.s_grading_rubrics[rubric.id] = rubric.total_points;
      sAlignmentRubricUpdate(rubric);
    }
  });
}]);

sAngular.addDirective('gradingRubricLaunch', ['$compile', 'gradingRubrics', function($compile, gradingRubrics){
  return {
    restrict : 'C',
    link : function(scope, element, attrs){

      var isDistrictMasteryEnabled = attrs.isDistrictMasteryEnabled === 'true';

      // to facilitate the Rubric Editor to work as a stand alone component in React
      element.on('ReactInit', function(event, rubric, saveHandler, cancelHandler, addAlignmentRowClickHandler, activeRubricUpdateHandler, isReadOnly){

        if($('.s-grading-rubric-edit-slider').length == 0) {
          // Compile Rubric Editor markup
          var rubricOutput = Drupal.theme.s_grades_grading_rubric_edit(false, true, false, isDistrictMasteryEnabled);
          $compile(rubricOutput)(scope).prependTo($('body'));
        }
        
        // Set state to open, and launch with special React options
        sAngular.rootScopeBroadcast('gradingRubricChangeState', 'opened');
        sAngular.rootScopeBroadcast('gradingRubricLaunch', {
          isReactComponent: true,
          rubric: rubric,
          saveHandler: saveHandler,
          cancelHandler: cancelHandler,
          addAlignmentRowClickHandler: addAlignmentRowClickHandler,
          activeRubricUpdateHandler: activeRubricUpdateHandler,
          isReadOnly: isReadOnly
        });

      });

      element.on('ReactCancelAndClose', function(){
        sAngular.rootScopeBroadcast('gradingRubricChangeState', 'closed-skip-cancel');
      });
      
      element.on('ReactAddAlignment', function(event, alignments){
        // figure difference
        $.each(alignments, function(idx, alignment){
          sAngular.rootScopeBroadcast('sAlignmentAdd', alignment);
        });
      });

      element.on('ReactRemoveAlignment', function(event, alignment){
        sAngular.rootScopeBroadcast('sAlignmentRemove', alignment);
      });

      element.click(function(event){
        var realm = attrs.realm;
        var realm_id = attrs.realmId;
        var itemNid = attrs.itemNid;
        var rubricId = attrs.rubricId;
        var isGradeItem = attrs.isGradeItem === 'true';
        var isResource = attrs.isResource === 'true';
        var isResourceMaterial = attrs.isResourceMaterial === 'true';
        var isReadOnly = attrs.isReadOnly === 'true';
        var wrapperClass = attrs.wrapperClass !== 'false' ? attrs.wrapperClass : false;

        var broadCastItemNid = false;
        if(isResourceMaterial || isGradeItem && angular.isDefined(itemNid) && itemNid != null ){
          broadCastItemNid = itemNid;
        }
        if(gradingRubrics.opened == false){
          gradingRubrics.opened = true;
          // Right now on a page, the grading rubric editor will either have grade item context or not.  This decision can be made when editing
          var rubricOutput = Drupal.theme.s_grades_grading_rubric_edit(isGradeItem, isResource, isReadOnly, isDistrictMasteryEnabled);
          $compile(rubricOutput)(scope).prependTo($('body'));
        }
        else{
          sAngular.rootScopeBroadcast('gradingRubricChangeState', 'opened');
        }

        var rubric = false;
        if (isResourceMaterial){
          var form = $(sLibraryRubricForms().join(', '));
          var jsonRubric = $('[name=resource_rubric]', form).val();
          if(wrapperClass){
            form = $('.' + wrapperClass, form);
            jsonRubric = $('input', form).val();
          }

          if(!jsonRubric) {
            var resourceRubricItem = $('#resource_rubric_' + itemNid);
            if (resourceRubricItem.length) {
              jsonRubric = resourceRubricItem[0].textContent;
            }
          }

          if (jsonRubric){
            rubric = JSON.parse(jsonRubric);
          } else {
            rubric = true;
          }
        }

        var createNew = $.inArray($('#edit-grading-scale-id').val(), ['e', 'r']) != -1;
        var gsSelectArea = $('#edit-grading-scale-id').parents('.grading-scale-select-grouping');

        // If there is a specific rubric let the rubric controller know
        var broadCastId = (angular.isDefined(rubricId) && rubricId != null) ? rubricId : false;
        sAngular.rootScopeBroadcast('rubricActiveIdChange', broadCastId);
        // Let the rubric know what realm/realm_id we care about
        sAngular.rootScopeBroadcast('gradingRubricLaunch', {
          'realm' : realm,
          'realmId': realm_id,
          'isReadOnly': isReadOnly,
          'itemNid' : broadCastItemNid,
          'isGradeItem': isGradeItem,
          'isResource': isResource,
          'rubric': rubric,
          'createNew': createNew,
          'gsSelectArea': gsSelectArea
        });
        // pre-populate rubric form
        var selectedRubricId = $('#edit-selected-rubric').val();
        if (selectedRubricId){
          if (Drupal.settings.s_grading_rubrics_info && Drupal.settings.s_grading_rubrics_info[selectedRubricId]){
            $.each(Drupal.settings.s_grading_rubrics_info[selectedRubricId]['rubric'].rows, function(idx, tagObj){
              sAngular.rootScopeBroadcast('sAlignmentAdd', tagObj)
            });
          }
          if (createNew) {
            // If this will be a new rubric, save the pre-populated information into Drupal.settings
            Drupal.settings.s_grading_rubrics_info.e = {rubric : { rows : Drupal.settings.s_grading_rubrics_info[selectedRubricId]['rubric'].rows } };
          }
        }
        if(angular.isDefined(Drupal.settings.s_alignment) && angular.isDefined(Drupal.settings.s_alignment.attached_tags)){
          $.each(Drupal.settings.s_alignment.attached_tags, function(tid, tagObj){
            if(isResourceMaterial || angular.isUndefined(itemNid) || tagObj.item_id == itemNid || tagObj.grade_item_nid == itemNid){
              sAngular.rootScopeBroadcast('sAlignmentAdd', tagObj);
            }
          });
        }
        scope.$apply();
      });
    }
  }
}]);

sAngular.addDirective('sGradingRubricEditSlider', function(){
  return {
    restrict : 'C', // bind this behavior to the s-grading-rubric-edit-slider class name
    link: function (scope, element, attrs) {

      // Setting the min- and max-limited height and width of the element and its internal structures
      function _setNewDimensions(newHeight, newWidth){
        var docWidth = $(window).width();
        var docHeight = $(window).height();
        var minWidth = 930;
        var minHeight = 250;
        var isReadOnly = scope.isReadOnly;
        // these offsets prevent whitespace from appearing between the bottom of the rubric rows and the top of the bottom-ctrls-wrapper
        var rightOffset = isReadOnly ? 0 : 40;
        var scrollOffset = isReadOnly ? 0 : 89;
        // scroll offset must account for any error messages
        var errorOffset = 0;
        $('.right-column .error.messages:visible').each(function() {
          errorOffset += $(this).outerHeight();
        });
        scrollOffset += errorOffset;
        var heightOffset = isReadOnly ? 69 : 89;
        newHeight = (newHeight > docHeight) ? docHeight : (newHeight < minHeight) ? minHeight : newHeight;
        // newWidth accounts for screens greater than docWidth and less than 930px. 
        // Example: tablet views with newWidth=750px, docWidth=768px, newWidth is set to docWidth
        newWidth = (newWidth > docWidth) ? docWidth : (docWidth < minWidth) ? docWidth : minWidth;
        // newLeft accounts for docWidth less than 930px. Example: tablet views with docWidth=768px left set to 0;
        newLeft = (docWidth < minWidth) ? 0 : docWidth - newWidth;
        element.css({
          'right': docWidth,
          'left': newLeft,
          'height': newHeight,
          'width': newWidth
        });
        $('.right-column', element).css({
          'height' : newHeight - rightOffset
        });
        $('.rubric-scroll', element).css({
          'height' : newHeight - scrollOffset
        });
        $('#grading-rubric-edit-slider .ui-resizable-w').css({
          'height': newHeight + heightOffset
        });
      }

      scope.$on('gradingRubricLaunch', function(){
        _setNewDimensions(400, 750);
      });
      
      element.resizable({
        handles:'w,sw,s',
        resize: function( event, ui ) {
          _setNewDimensions(ui.size.height, ui.size.width);
        },
        create: function( event, ui ) {
          element.css({
            'position': 'absolute',
            'max-width': 9999, // limited based on the document width
            'max-height': 9999
          });
          _setNewDimensions(400, 750);
        }
      });
    }
  }
});


// CONTROLLER FOR THE GRADING RUBRIC EDIT SLIDER
sAngular.addController('s_grading_rubric_edit', ['$scope','gradingRubrics', function($scope, gradingRubrics){
  $scope.activeRubricId = 'e';
  $scope.rubricTable = null;
  $scope.saving = false;
  $scope.state = 'opened';
  $scope.defaultTitle = '';
  $scope.rubricSort = 'created';
  $scope.rubrics = {};
  $scope.hasAlignments = false;
  $scope.hasTitleError = false;
  $scope.errorMessage = '';
  $scope.dirtyRubrics = [];
  $scope.rubricSliderContext = null;
  $scope.ptsErrorCells = [];
  $scope.expandedClass = '';

  $scope.selectGradingScale = function($event) {
    var $button = $($event.currentTarget);

    sCommonConfirmationPopup({
      title : Drupal.t("Please Confirm"),
      body : Drupal.t("Do you want to replace your current scale(s) with the selected scale? This action cannot be undone."),
      extraClass : "apply-grading-scale-popup",
      confirm : {
        func : function() {
          $scope.$apply(function() {
            var tempRow;
            var totalPoints = 0,
              newRows = [],
              newRubric = angular.copy($scope.rubrics[$scope.activeRubricId]),
              scaleInfo = $button.data("scale-info");

            sPopupsClose();

            $.each($scope.rubrics[$scope.activeRubricId].rows, function(idx, obj) {
              tempRow = angular.copy(templateRubricRow);
              totalPoints += scaleInfo.max_points;
              tempRow.max_points = scaleInfo.max_points;
              tempRow.columns = scaleInfo.columns;
              tempRow.title = this.title || "";
              tempRow.is_published = obj.is_published;
              tempRow.description = this.description || "";
              tempRow.tid = obj.tid;
              tempRow.guid = obj.guid;

              newRows.push(tempRow);
            });

            newRubric.total_points = totalPoints;

            newRubric.rows = newRows;
            $scope.rubrics[$scope.activeRubricId] = angular.copy(newRubric);
          });
        }
      }
    });
  };

  $scope.rubricSortOptions = [
  {
    title : 'Recently Added',
    field : '-created'
  },

  {
    title : 'Most Used',
    field : '-num_assigned_gi'
  }
  ];
  $scope.savedRubricsList = []; // ng-repeat does not like filtering on objects.  Save a list for our left menu ng-repeat
  $scope.sortableOptions = {
    handle : '.sort-handle'
  }
  /*
   * This isGradeItem flag is extremely important. Behavior diverges greatly between the rubric slider that interacts with
   * a grade item form and the rubric slider that is in the grade setup page.  This flag is what helps us with that behavior
   */
  $scope.$watch('isGradeItem', function(newVal, oldVal){
    $scope.defaultTitle = newVal ? Drupal.t('Custom Rubric') : Drupal.t('New Rubric');
    if (newVal) {
      $scope.rubrics.e.title = '';
    }
  })

  var templateRubricRow = {
    id : null, // Everything is done by ID out here in the DOM, but back on the server each row has an id
    title : '',
    description : '',
    tid : null,
    guid : null,
    max_points : 4,
    columns : [
      {
        pts : 4,
        description : Drupal.t('Excellent')
      },
      {
        pts : 3,
        description : Drupal.t('Good')
      },
      {
        pts : 2,
        description : Drupal.t('Satisfactory')
      },
      {
        pts : 1,
        description : Drupal.t('Needs Improvement')
      }
    ]
  };

  var templateRubric = {
    id : 'd', // 'd' for our default template.  This id should never be seen outside of here
    title : $scope.defaultTitle,
    total_points : 4,
    realm_id : null,
    realm : null,
    rows : []
  };
  templateRubric.rows.push(templateRubricRow);

  $scope.makeEditRubric = function(){
    // Clone our default so user is editing that one
    var editTemplate = angular.copy(templateRubric);
    editTemplate.realm_id = gradingRubrics.realmId;
    editTemplate.realm = gradingRubrics.realm;
    editTemplate.id = 'e'; // 'e' for the template that is being edited.  Once saved it will get an ID from the server
    $scope.rubrics.e = editTemplate;
    if(!$scope.isGradeItem){
      $scope.rubrics.e.title = '';
    }
  }

  // Make our initial editing rubric
  $scope.makeEditRubric();

  $scope.addSavedRubric = function(rubric){
    var savedRubObj = {
      id : rubric.id,
      title : rubric.title,
      total_points : rubric.total_points,
      created : rubric.created,
      num_assigned_gi : rubric.num_assigned_gi
    }

    savedRubObj.num_assigned_infotip = (savedRubObj.num_assigned_gi > 0) ? Drupal.formatPlural(rubric.num_assigned_gi, 'This rubric is being used on 1 item', 'This rubric is being used on @count items') : '';

    $scope.savedRubricsList.push(savedRubObj);
  }

  $scope.$on('gradingRubricChangeState', function(event, newState){
    $scope.changeState(newState);
  });

  $scope.submitButtonText = function(){
    return ($scope.activeRubricId == 'e') ? Drupal.t('Create') : Drupal.t('Save');
  };

  $scope.toggleLoading = function(addOverlay){
    if(addOverlay){
      sToggleActiveLoader('grading-rubric-panel', $('#grading-rubric-edit-slider'));
    }
    else{
      sToggleActiveLoader('grading-rubric-panel');
    }
  }

  $scope.getSaveRubricClass = function(rubricId){
    var classStr = '';
    if(rubricId == $scope.activeRubricId){
      classStr += ' active';
    }
    if($scope.hasAlignments){
      classStr += ' disabled';
    }
    return classStr;
  }
  $scope.setRubricSort = function(sort){
    $scope.rubricSort = sort.field;
  }

  $scope.$on('rubricActiveIdChange', function(event, newId){
    if (newId && newId != 'e') {
      sAlignmentResetAttachedAlignments();
    }
    if(newId !== false && ($.isNumeric(newId) || newId == 'e')){
      $scope.activeRubricId = newId;
    }
    else if(newId === false){
      $scope.makeEditRubric();
      $scope.activeRubricId = 'e';
      if (angular.isUndefined(Drupal.settings.s_alignment)) {
        Drupal.settings.s_alignment = {attached_tags: {}};
      }
    }
    if(!$scope.$$phase){
      $scope.$apply();
    }
    $scope.rubricAlignmentSanity();
  });

  $scope.$on('gradingRubricLaunch', function(event, data){
    var $defaultGradingScaleWrapper = $('#default-grading-scale-wrapper');
    $scope.isReactComponent = data.isReactComponent;
    $scope.resetErrors();

    if ($scope.isReactComponent === true) {
      $scope.saveHandler = data.saveHandler;
      $scope.cancelHandler = data.cancelHandler;
      $scope.activeRubricUpdateHandler = data.activeRubricUpdateHandler;
      $scope.addAlignmentRowClickHandler = data.addAlignmentRowClickHandler;
      $scope.isReadOnly = data.isReadOnly;
      if (data.rubric === null){
        $scope.makeEditRubric();
      } else {
        $scope.rubrics.e = data.rubric;
        $scope.activeRubricId = 'e'; 
      }
      $scope.rubricAlignmentSanity();
      $scope.focusTitleInput();
      $scope.calculateNewTotalPoints();
      $scope.toggleLoading(false);
    } else {
      $scope.toggleLoading(true);
      $scope.realm = data.realm;
      $scope.realmId = data.realmId;
      $scope.isReadOnly = data.isReadOnly;
      $scope.ptsErrorCells = [];
      $scope.isGradeItem = data.isGradeItem;
      $scope.isResource = data.isResource;
      $scope.rubric_handled_manually = false;
      $scope.createNew = data.createNew;
      $scope.gsSelectArea = data.gsSelectArea;

      // Scope Variables to handle

      // if a rubric is passed in, user will be responsible for responding to triggered events
      if (data.rubric) {
        $scope.rubric_handled_manually = true;
      }
      if ($scope.rubric_handled_manually && angular.isObject(data.rubric)) {
        $scope.rubrics.e = data.rubric;
        $scope.activeRubricId = 'e';
        $scope.rubricAlignmentSanity();
        $scope.focusTitleInput();
        $scope.toggleLoading(false);
      }
      else if ($scope.isResource) {
        $scope.savedRubricsList = [];
        if (data.itemNid != 'e') {
          gradingRubrics.getResourceRubricById($scope.realmId, data.itemNid, function (rubric) {
            $scope.savedRubricsList = [];
            var rubricCopy = angular.copy(rubric);
            $scope.addSavedRubric(rubric);
            $scope.rubrics[rubric.nid] = rubric;
            $scope.activeRubricId = rubric.nid;
            $scope.rubricAlignmentSanity();
            $scope.toggleLoading(false);
            $scope.focusTitleInput();
          });
        } else {
          $scope.rubricAlignmentSanity();
          $scope.toggleLoading(false);
          $scope.focusTitleInput();
        }

      }
      // editor view is read only
      else if ($scope.isReadOnly && $scope.activeRubricId) {
        gradingRubrics.getRubricById($scope.activeRubricId, function (rubric) {
          $scope.rubrics[rubric.id] = angular.copy(rubric);
          $scope.toggleLoading(false);
        });
      } else {
        gradingRubrics.getRubricsByCourse($scope.realmId, data.itemNid, function (rubrics) {
          $scope.savedRubricsList = [];
          var rubricsCopy = angular.copy(rubrics);
          $.each(rubricsCopy, function (k, rubric) {
            $scope.addSavedRubric(rubric);
            $scope.rubrics[k] = rubric;
          });
          $scope.rubricAlignmentSanity();
          $scope.toggleLoading(false);
          $scope.focusTitleInput();
        });
      }
    }

    $defaultGradingScaleWrapper.sActionLinks({
      hidden: false
    });

    $defaultGradingScaleWrapper.tipsy({
      title : function() {
        return Drupal.t("Select a scale if you want to replace your current grading scale(s). This action cannot be undone.");
      },
      gravity : "e"
    });

    $('#default-grading-scale-wrapper-disabled').tipsy({
      title : function() {
        return Drupal.t("To enable, first create a point-based scale in your gradebook setup.");
      },
      gravity : "e"
    });

    $scope.rubricTable = $('.rubric-table');

    $('.control-btn').tipsy({
      gravity : function() {
        if ($scope.state === 'slide-closed') {
          return 'ne';
        }
        return $scope.expandedClass === '' ? 'n' : 'nw';
      },
      title : function() {
        var $button = $(this);
        var isEditor = $button.parents('.readonly').length == 0;
        if ($button.hasClass('close-btn')) {
          if (isEditor) {
            return Drupal.t('Close Rubric Editor');
          } else {
            return Drupal.t('Close Rubric');
          }
        }
        if ($button.hasClass('slide-btn')) {
          if (isEditor) {
            return $scope.state === 'slide-closed' ? Drupal.t('Show Rubric Editor') : Drupal.t('Hide Rubric Editor');
          } else {
            return $scope.state === 'slide-closed' ? Drupal.t('Show Rubric') : Drupal.t('Hide Rubric');
          }
        }
        if ($button.hasClass('expand-btn')) {
          return $scope.expandedClass === '' ? Drupal.t('Show Expanded Rubric Editor') : Drupal.t('Show Normal Rubric Editor');
        }
        return '';
      }
    });
  });

	$scope.updateResourcesMainContent = function(){
    if ($scope.isReactComponent === true) {
      return;
    }
		if ($scope.isResource){
			// if in Resources, reload the main content 
			var libraryWrapper = $('#library-wrapper');
			var currentUrl = sLibraryGetHash();
			sLibraryUpdateMainContent(libraryWrapper, currentUrl, false, false);
		}
	};

  $scope.$on('gradingRubricSaveSuccess', function(event, rubric, isNew){
    if ($scope.isReactComponent === true) {
      return;
    }
	  $scope.updateResourcesMainContent();
    if(isNew){
      if(!$scope.isResources && sIsset(Drupal.settings.s_grading_rubrics_info)){
        Drupal.settings.s_grading_rubrics_info[rubric.id] = sAlignmentRubricInfo(rubric);
      }
      if($scope.isGradeItem){
        $scope.activeRubricId = rubric.id;
        $scope.rubrics[rubric.id] = rubric;
        $scope.addSavedRubric(rubric);
        $scope.makeEditRubric();
      } else {
        $scope.activeRubricId = rubric.id;
        $scope.rubrics[rubric.id] = rubric;
        delete $scope.rubrics.e;
        if ($scope.realm == 'course') {
          sAngular.rootScopeBroadcast('gradingRubricSelect', rubric);
        }
      }
      sAngular.rootScopeBroadcast('gradingRubricSelect', rubric);
    }
    else{
      // In a save, expect an array of edited rubrics
      $.each(rubric, function(k, v){
        if(!sIsset(Drupal.settings.s_grading_rubrics_info)) {
          Drupal.settings.s_grading_rubrics_info = {};
        }
        Drupal.settings.s_grading_rubrics_info[v.id] = sAlignmentRubricInfo(v);
        sAngular.rootScopeBroadcast('gradingRubricSelectModify', v);
      })
    }
    $scope.changeState('closed');
    $scope.saving = false;
    $scope.toggleLoading(false);
  });

  $scope.$on('sAlignmentAdd', function(event, term){
    if ($scope.isReactComponent === true) {
      $.each($scope.rubrics[$scope.activeRubricId].rows, function (k, v) {
        // search to see if the alignment is already on the rubric
        if (v.tid && v.tid == term.guid) {
          // use TID
          alignmentExists = true;
        } else if (v.guid && v.guid == term.guid) {
          // use GUID
          alignmentExists = true;
        }
      });
      if (alignmentExists){
        return;
      }
      var alignmentExists = false;
      var newRowIndex = $scope.addRow(true);
      
      if(newRowIndex != undefined) {
        // currently always published when incoming from isReactComponent
        $scope.rubrics[$scope.activeRubricId].rows[newRowIndex].description = term.description;
        $scope.rubrics[$scope.activeRubricId].rows[newRowIndex].title = term.name;
        $scope.rubrics[$scope.activeRubricId].rows[newRowIndex].guid = term.guid;
        $scope.rubrics[$scope.activeRubricId].rows[newRowIndex].is_published = true;
      }
      if ($scope.activeRubricUpdateHandler){
        // update pending rubric
        $scope.activeRubricUpdateHandler($scope.rubrics[$scope.activeRubricId]); 
      }
      return;
    }
    var alignmentExists = false;
    var is_published = (typeof term.is_published == 'undefined' || term.is_published > 0);
    if($scope.rubrics[$scope.activeRubricId] == undefined) {
      // no-op
    } else if (is_published) {
      $.each($scope.rubrics[$scope.activeRubricId].rows, function (k, v) {
        if (v.guid == term.guid) {
          alignmentExists = true;
          return false;
        }
      });
    } else {
      $.each($scope.rubrics[$scope.activeRubricId].rows, function (k, v) {
        if (v.title == term.title && v.description == term.description) {
          alignmentExists = true;
          return false;
        }
      });
    }
    if(alignmentExists){
      return;
    }
    var newRowIndex = $scope.addRow(true);

    if(newRowIndex != undefined) {
      $scope.rubrics[$scope.activeRubricId].rows[newRowIndex].description = term.description;
      $scope.rubrics[$scope.activeRubricId].rows[newRowIndex].title = term.title ? term.title : term.name;
      $scope.rubrics[$scope.activeRubricId].rows[newRowIndex].guid = term.guid ? term.guid : '';
      $scope.rubrics[$scope.activeRubricId].rows[newRowIndex].is_published = is_published;
    }

    $scope.rubricAlignmentSanity();
    
    if(!$scope.$$phase){
      $scope.$apply();
    }
  });

  $scope.$on('sAlignmentRemove', function(event, term){
    if ($scope.isReactComponent === true) {
      $.each($scope.rubrics[$scope.activeRubricId].rows, function (i, row) {
        var tidOrGuid = row.guid ? row.guid : row.tid;
        if (tidOrGuid == term.guid) {
          $scope.removeRow(i);
          return false;
        }
      });
      if ($scope.activeRubricUpdateHandler){
        // update pending rubric
        $scope.activeRubricUpdateHandler($scope.rubrics[$scope.activeRubricId]);
      }
    } else {
      $.each($scope.rubrics[$scope.activeRubricId].rows, function (i, row) {
        if (angular.isDefined(row.guid) && row.guid == term.guid) {
          $scope.removeRow(i);
          return false;
        }
      });
    }
    $scope.rubricAlignmentSanity();
    if(!$scope.$$phase){
      $scope.$apply();
    }
  });

  $scope.getExpandButtonClass = function() {
    return $scope.state === 'slide-closed' ? 'ng-cloak' : '';
  }

  $scope.rubricBodyClass = function(){
    var classStr = $scope.state;
    if($scope.state == 'closed'){
      classStr += ' hidden';
    }
    classStr += ($scope.isGradeItem ? ' grade-item-rubric-edit' : ' grade-setup-rubric-edit');
    if(!$scope.isGradeItem){
      classStr += $scope.activeRubricId == 'e' ? ' new-rubric-edit' : ' existing-rubric-edit';
    }

    if ($scope.expandedClass) {
      classStr += " " + $scope.expandedClass;
    }

    if ($scope.isReadOnly) {
      classStr += " read-only";
    }

    return classStr;
  }

  /*
   * To edit they must either be on the grade setup page OR on assignment page and editing the 'edit' rubric
   */
  $scope.isEditable = function(){
    return !$scope.isReadOnly;
  };

  $scope.focusTitleInput = function(){
    $('#rubric-title-input').focus();
  }

  $scope.rubricItemClick = function(event, rubricId){
    // Non Alignment rubrics only selectable
    if($scope.isGradeItem){
      return;
    }
    $scope.activeRubricId = rubricId;
    $scope.focusTitleInput();
  }

  // Run sanity on the state of the rubric to make sure that it has either all custom rows or all alignment rows
  // Having alignments trumps custom criteria
  $scope.rubricAlignmentSanity = function(){
    if(angular.isUndefined($scope.rubrics[$scope.activeRubricId]) || angular.isUndefined($scope.rubrics[$scope.activeRubricId].rows)){
      return;
    }
    var tempHasAlignments = false; // assume no alignments
    $.each($scope.rubrics[$scope.activeRubricId].rows, function(i, row){
      if(angular.isDefined(row) && angular.isDefined(row.guid) && row.guid != null && row.guid != ''){
        tempHasAlignments = true;
      }
    });
    $scope.hasAlignments = tempHasAlignments;
  }

  $scope.$watch('rubrics', function(newVal, oldVal){
    if(angular.isUndefined($scope.rubrics[$scope.activeRubricId])){
      return;
    }

    if($scope.rubricSliderContext === null){
      $scope.rubricSliderContext = $('.grade-setup-rubric-edit');
    }

    // Collect a list of the IDs that have been dirtied
    if($scope.rubrics[$scope.activeRubricId].title != ''){
      if($.inArray($scope.activeRubricId, $scope.dirtyRubrics) === -1){
        $scope.dirtyRubrics.push($scope.activeRubricId);
      }
    }
    sGradesResizeInnerTable($scope.rubricSliderContext);
  },true);

  /**
   * @deprecated this is not used anywhere
   */
  $scope.$on('gradingRubricRowReorder', function(event, startIndex, stopIndex){
    $scope.$apply(function(){
      var movedRow = $scope.rubrics[$scope.activeRubricId].rows[startIndex];
      if(angular.isUndefined(movedRow)){
        return;
      }
      $scope.rubrics[$scope.activeRubricId].rows.splice(startIndex, 1);
      $scope.rubrics[$scope.activeRubricId].rows.splice(stopIndex, 0, movedRow);
    })
  });

  $scope.hasNumericPointsError = function(){
    var hasError = false;
    $.each($scope.ptsErrorCells, function(rowIndex, columnErrors){
      if(typeof columnErrors == 'object' && columnErrors.length > 0){
        hasError = true;
        return false;
      }
    })
    return hasError;
  }

  $scope.cellHasError = function(rowIndex, columnIndex){
    if(angular.isDefined($scope.ptsErrorCells[rowIndex]) && typeof $scope.ptsErrorCells[rowIndex] == 'object' && $scope.ptsErrorCells[rowIndex][columnIndex] == 1){
      return true;
    }
    return false;
  }

  $scope.rowPointsChange = function(rowIndex){
    var row = $scope.rubrics[$scope.activeRubricId].rows[rowIndex];
    // Find our new max points when this changes
    var newMaxPoints = 0;
    var hasError = false;
    $.each(row.columns, function(k,v){
      if(angular.isUndefined($scope.ptsErrorCells[rowIndex])){
        $scope.ptsErrorCells[rowIndex] = [];
      }
      if(!$.isNumeric(v.pts)){
        $scope.ptsErrorCells[rowIndex][k] = 1;
        hasError = true;
      }
      else{
        $scope.ptsErrorCells[rowIndex][k] = 0;
      }
      v = sGradesRoundNumber(v.pts);
      if(v > newMaxPoints){
        newMaxPoints = v;
      }
    });

    if(hasError){
      $scope.errorMessage = Drupal.t('Grading Scale point values must be strictly numeric');
    }
    else{
      // No error in the row then make sure the ptsErrorCells error tracker is empty
      $scope.ptsErrorCells[rowIndex] = [];
    }

    // If there was a title error but it has since been resolved, make sure to indicate this
    if($scope.hasTitleError && $scope.rubrics[$scope.activeRubricId].title != ''){
      $scope.hasTitleError = false;
    }

    $scope.rubrics[$scope.activeRubricId].rows[rowIndex].max_points = sGradesRoundNumber(newMaxPoints);
    $scope.calculateNewTotalPoints();
  }
  $scope.calculateNewTotalPoints = function(){
    // Calculate our new totalpoints
    var newTotalPoints = 0;
    var rubric = $scope.rubrics[$scope.activeRubricId];
    $.each(rubric.rows, function(k,row){
      var pts = sGradesRoundNumber(row.max_points);
      if($.isNumeric(pts)){
        newTotalPoints += pts;
      }
    });
    if(newTotalPoints != null){
      $scope.rubrics[$scope.activeRubricId].total_points = sGradesRoundNumber(newTotalPoints);
    }
  }

  $scope.sortColumns = function(rowIndex){
    $scope.rubrics[$scope.activeRubricId].rows[rowIndex].columns = $scope.rubrics[$scope.activeRubricId].rows[rowIndex].columns.sort(function(a,b){
      return b.pts - a.pts;
    });
  }

  $scope.addColumn = function(rowIndex, colIndex, adjust){
    if(!$scope.isEditable()){
      return;
    }
    adjust = parseInt(adjust);
    var columns = $scope.rubrics[$scope.activeRubricId].rows[rowIndex].columns;
    var targetCell = columns[colIndex];
    var newTargetCell = angular.copy(targetCell);
    if((colIndex + adjust >= 0) && (colIndex + adjust) <= (columns.length - 1)){
      newTargetCell.pts = Math.min(columns[colIndex].pts, columns[colIndex + adjust].pts) + Math.floor(Math.abs(columns[colIndex].pts - columns[colIndex + adjust].pts)/2);
    }
    $scope.rubrics[$scope.activeRubricId].rows[rowIndex].columns.push(newTargetCell);
    $scope.sortColumns(rowIndex);
    
    // the tooltip is hanging around, this will remove all active tooltips 
    $('.tipsy-e').remove();
  }

  $scope.removeColumn = function(rowIndex, colIndex){
    if(!$scope.isEditable() || $scope.rubrics[$scope.activeRubricId].rows[rowIndex].columns.length == 1){
      return;
    }
    $scope.rubrics[$scope.activeRubricId].rows[rowIndex].columns.splice(colIndex,1);
    $scope.calculateNewTotalPoints();
    $scope.rowPointsChange(rowIndex);
  }

  $scope.addRowClick = function(){
    return $scope.addRow(false);
  }

  // return markup for a row styled as an element for the selected-container
  $scope.selectedElementRow = function (row){
    return $('<div class="selected-item active visually-hidden" id="' + row.guid + '"><input type="checkbox" class="std-selector"><span class="title">' + row.title + '</span> · <span class="meta small gray">' + row.description + '</span></div>');
  }
  
  $scope.fillSelectedBox = function(){
    if ($scope.isReactComponent === true) {
      return;
    }
    sAlignmentRubricUpdate($scope.rubrics[$scope.activeRubricId]);
    sAlignmentUpdateSelectedCount();
    $.each($scope.rubrics[$scope.activeRubricId].rows, function(idx, obj){
      if (obj.is_published){
        // add this to the selected box
        var el = $scope.selectedElementRow(obj);
        $('.selected-container').append(el);
        sAlignmentAddItem(el, true);
      }
    });
  }

  $scope.addAlignmentRowClick = function(){
    if ($scope.isReactComponent === true) {
      if ($scope.activeRubricUpdateHandler){
        // update pending rubric
        $scope.activeRubricUpdateHandler($scope.rubrics[$scope.activeRubricId]);
      }
      $scope.addAlignmentRowClickHandler();
      return;
    }
    // attempt to get the active form
    var form = sAlignmentGetActiveForm();
    if (!form) {
      // default to the old method of form retrieval
      form = $('.alignment-btn').parents('form').eq(0);
    }
    var alignmentFormContainer = $('.alignment-form-container');
    alignmentFormContainer.attr('id', 'form_'+form.attr('id'));
    
    $scope.fillSelectedBox();
    //pass override to handler
    $('.alignment-btn:not(.disabled), .alignment-btn.disabled-rubric-selected', form).trigger('click', {'override': true});
    return;
  }

  // Add a rubric row and return the index
  $scope.addRow = function(isAlignment){
    if ($scope.isReactComponent === true) {
      if ($scope.activeRubricUpdateHandler){
        // update pending rubric
        $scope.activeRubricUpdateHandler($scope.rubrics[$scope.activeRubricId]);
      }
    }

    if(!$scope.isEditable()){
      return;
    }
    // If adding the first alignment
    if (isAlignment && angular.equals($scope.rubrics[$scope.activeRubricId].rows[0], templateRubric.rows[0])){
      // Replace the current placeholder criteria row (The default row that loads with a new rubric)
      return 0;
    }
    var newRow = angular.copy(templateRubric.rows[0]);
    if($scope.rubrics[$scope.activeRubricId].rows.length > 0){
      var newColumns = angular.copy($scope.rubrics[$scope.activeRubricId].rows[$scope.rubrics[$scope.activeRubricId].rows.length - 1].columns);
      newRow.columns = newColumns;
    }
    $scope.rubrics[$scope.activeRubricId].rows.push(newRow);
    $scope.calculateNewTotalPoints();
    var newRowIndex = ($scope.rubrics[$scope.activeRubricId].rows.length - 1);
    $scope.rowPointsChange(newRowIndex);

    return newRowIndex;
  }
  $scope.removeRow = function(rowIndex){

    if(!$scope.isEditable()){
      return;
    }

    var row = $scope.rubrics[$scope.activeRubricId].rows[rowIndex];
    // If this is an alignment row and the form function exists, remove from form
    if(!$scope.isReactComponent && angular.isDefined(row.guid) && row.guid != null && typeof sAlignmentRemoveItem == 'function'){
      sAlignmentRemoveItem(row.guid, false);
    }

    $scope.rubrics[$scope.activeRubricId].rows.splice(rowIndex,1);
    if($scope.rubrics[$scope.activeRubricId].rows.length == 0){
      $scope.addRow(false);
      $scope.rubricAlignmentSanity(); // Could have changed if this is an alignment rubric if all tags deleted
    }
    $scope.calculateNewTotalPoints();
    $scope.fillSelectedBox();

    // the tooltip is hanging around, this will remove all active tooltips 
    $('.tipsy-e').remove();

    if ($scope.isReactComponent === true && $scope.activeRubricUpdateHandler) {
      // update pending rubric
      $scope.activeRubricUpdateHandler($scope.rubrics[$scope.activeRubricId]);
    }
  }

  $scope.setTitleError = function(){
    $scope.errorMessage = Drupal.t('Rubrics must have a title');
    $scope.hasTitleError = true;
  }

  $scope.removeAngularElementsFromObject = function(object){
    // removes angular elements like $$haskKey
    var json = angular.toJson(object);
    return JSON.parse(json);
  };

  $scope.setCriteriaError = function(row_idx){
    if (!$scope.errorCriteriaRows){
      $scope.errorCriteriaRows = {};
    }
    $scope.errorCriteriaRows[row_idx] = true;
    $scope.criteriaErrorMessage = Drupal.t('All criteria must have a title');
    $scope.hasCriteriaError = true;
  }
  
  $scope.resetErrors = function(){
    $scope.hasTitleError = false;
    $scope.hasCriteriaError = false;
    $scope.errorCriteriaRows = {};
  }
  
  $scope.rubricFormSubmit = function(isSubmit){
    if(isSubmit){
      if($scope.hasNumericPointsError()){
        return;
      }
      
      $scope.resetErrors();
      
      // check for title error
      if($scope.rubrics[$scope.activeRubricId].title == ''){
        $scope.setTitleError();
      }
      // check for criteria title error
      $.each($scope.rubrics[$scope.activeRubricId].rows, function(idx, row){
        if (!row.is_published && row.title == '') {
          $scope.setCriteriaError(idx);
        }
      });
      
      if ($scope.hasCriteriaError || $scope.hasTitleError){
        return;
      }

      $scope.toggleLoading(true);

      if ($scope.isReactComponent === true) {
        if ($scope.saveHandler) {
          $scope.saveHandler($scope.removeAngularElementsFromObject($scope.rubrics.e));
        }
        return;
      }
      if ($scope.rubric_handled_manually){
        var form = $(sLibraryRubricForms().join(', '));
        form.trigger('sLibraryResourceMaterialRubricUpdated', $scope.rubrics.e);
        $scope.toggleLoading(false);
        $scope.changeState('closed');
      }
      // interacting with grade item form, behave differently
      else if($scope.isGradeItem){
        $scope.saving = true;
        if($scope.activeRubricId == 'e'){
          gradingRubrics.createRubric($scope.realm, $scope.realmId, $scope.rubrics.e);
        }
        else{
          var editRubrics = [$scope.rubrics[$scope.activeRubricId]];
          gradingRubrics.saveRubrics($scope.realm, $scope.realmId, editRubrics);
        }
      }
      else{
        var editRubrics = [];
        if($scope.dirtyRubrics.length > 0){
          $.each($scope.dirtyRubrics, function(i, rubId){
            if(rubId == 'e' && $scope.rubrics.e.title != ''){
              gradingRubrics.createRubric($scope.realm, $scope.realmId, $scope.rubrics.e);
            }
            else{
              editRubrics.push($scope.rubrics[rubId]);
            }
          });

          if(editRubrics.length > 0){
            gradingRubrics.saveRubrics($scope.realm, $scope.realmId, editRubrics);
          }
        }
        $scope.dirtyRubrics = [];
      }
      sAlignmentResetAttachedAlignments();
    }
    else{
      if ($scope.isReactComponent === true) {
        if ($scope.cancelHandler) {
          $scope.cancelHandler();
        }
        $scope.toggleLoading(false);
        $scope.changeState('closed');
        return;
      }
      sAlignmentClearPendingAlignments($scope.createNew);
      $scope.changeState('closed');
      if($scope.createNew && $scope.isResource){
        $('select#edit-grading-scale-id').selectmenu('value', 0);
        sGradeScaleClearRubricSelection($scope.gsSelectArea);
      }
    }
    sAlignmentResetAttachedAlignments(true);
    $scope.makeEditRubric();
    $scope.activeRubricId = 'e';
  };

  $scope.$on('gradingRubricDeleteSuccess', function(event, rubricId){
	  $scope.updateResourcesMainContent();
    // If they somehow found a way to delete the rubric they are currently editing
    if($scope.activeRubricId == rubricId){
      $scope.makeEditRubric();
      $scope.activeRubricId = 'e';
    }

    delete $scope.rubrics[rubricId];
  });

  $scope.changeState = function(newState){
    if ($scope.isReactComponent === true && (newState === 'closed' || newState === 'closed-skip-cancel')) {
      if (newState !== 'closed-skip-cancel') {
        if ($scope.cancelHandler) {
          $scope.cancelHandler();
        }
      } else {
        // The legacy editor does not support the state 'closed-skip-cancel', so revert to close after skipping the cancel
        newState = 'closed';
      }
    }
    var oldState = $scope.state;
    if(oldState == 'slide-closed' && newState == 'slide-closed'){
      newState = 'opened';
    }
    $scope.state = newState;
    if(!$scope.$$phase){
      $scope.$apply();
    }
  };

  $scope.toggleExpandedState = function() {
    $scope.expandedClass = $scope.expandedClass === '' ? 'grading-rubric-edit-slider--expanded' : '';
  };
    
  $scope.canAddAlignments = function(){
    // Only allow alignments on grade item impromptu forms
    if(!$scope.isGradeItem || angular.isUndefined($scope.rubrics[$scope.activeRubricId])){
      return false;
    }
    var ret = ($scope.hasAlignments || angular.isUndefined($scope.rubrics[$scope.activeRubricId].rows) || $scope.rubrics[$scope.activeRubricId].rows.length == 1);
    return ret;
  };

  $scope.alignmentHidden = function(){
    return (!$('.alignment-btn:not(.disabled), .alignment-btn.disabled-rubric-selected').length && !$scope.isReactComponent);
  };
}]);

sAngular.addController('s_grades_grading_rubrics_block', ['$scope','gradingRubrics', function($scope, gradingRubrics){
  $scope.rubrics = null;
  // This will be set by the page we are on, that is why we will not listen for the event transmitted
  $scope.realm = Drupal.settings.s_realm_info.realm;
  $scope.realmId = Drupal.settings.s_realm_info.realm_id;

  $scope.addPopupsBehavior = function(){
    setTimeout(function(){
      sAttachBehavior('popups', $(document));
    }, 0);
  }
  
  gradingRubrics.getRubricsByCourse($scope.realmId, false, function(rubrics){
    var filteredRubrics = [];
    $.each(rubrics, function(i, rubric){
      if(rubric.is_tracked != true) {
        rubric.num_assigned_infotip = (rubric.num_assigned_gi > 0) ? Drupal.formatPlural(rubric.num_assigned_gi, 'This rubric is being used on 1 item', 'This rubric is being used on @count items') : '';
        //apply to drupal settings
        if (!sIsset(Drupal.settings.s_grading_rubrics)) {
          Drupal.settings.s_grading_rubrics = {};
        }
        Drupal.settings.s_grading_rubrics[rubric.id] = rubric.total_points;
      } else {
        filteredRubrics.push(rubric.id);
      }
    })
    for(var i in filteredRubrics) {
      var rubricId = filteredRubrics[i];
      delete rubrics[rubricId];
    }

    // Need to make sure server response is not an empty array
    $scope.rubrics = (typeof rubrics == 'object' && angular.isUndefined(rubrics.length)) ? rubrics : {};
    if(!$scope.$$phase){
      $scope.$apply();
    }
    $scope.addPopupsBehavior();
  });

  $scope.$on('gradingRubricSaveSuccess', function(event, rubric, isNew){
	  if(isNew){
      $scope.rubrics[rubric.id] = rubric;
      $scope.activeRubricId = rubric.id;
      sAlignmentRubricUpdate(rubric);
      if(!$scope.$$phase){
        $scope.$apply();
      }
      $scope.addPopupsBehavior();
    }
  });

  $scope.$on('gradingRubricDeleteSuccess', function(event, rubricId){
    delete $scope.rubrics[rubricId];
  });
}]);

sAngular.addDirective('gradingRubricGradingLaunch', ['$compile', 'gradingRubrics', function($compile, gradingRubrics){
  return {
    scope : {},
    restrict : 'C',
    link : function(scope, element, attrs){
      scope.rubricId = attrs.rubricId;
      scope.enrollmentId = attrs.enrollmentId;
      scope.itemId = attrs.itemId;
      scope.opened = false;
      scope.editable = attrs.editable == 1;
      scope.isComponent = attrs.isComponent == 1;
      scope.submissionId = attrs.submissionId;
      scope.totalRubricPoints = parseFloat(attrs.totalRubricPoints);
      scope.textOnly = (attrs.textOnly === 'true');

      // When a grade is saved, update if this is the pertinent scope
      scope.$on('gradingRubricTotalGradeUpdate', function(event, data){
        if (data.isDistrictMasteryGrading) {
          return;
        }
        if(parseInt(data.enrollmentId) == parseInt(scope.enrollmentId) && parseInt(data.itemId) == parseInt(scope.itemId) && parseInt(data.rubricId) == parseInt(scope.rubricId) && (data.submissionId == scope.submissionId)){
          var rubricFakeInput = $('.rubric-fake-grade-disp .grade-val', element);
          var gradeScoreObj = rubricFakeInput.parents('.grade-score');
          var override = gradeScoreObj.children('.input-override').children('input');
          var maxPoints = sGradesRoundNumber(gradeScoreObj.children('.input-max-points').children('input').val());
          var rubric_score = gradeScoreObj.children('.input-rubric-score').children('input');
          var score = gradeScoreObj.children('.input-score').children('.form-item').children('input');
          var questionPoints = $('#question-points-total-' + scope.itemId, gradeScoreObj);
          var rubricTotalPoints = $('#rubric-total-points-' + scope.itemId, gradeScoreObj);

          questionPoints.tipsy({
            title : function() {
              return Drupal.t("This score contributes to the cumulative test score");
            },
            gravity : "s"
          });
          rubricTotalPoints.tipsy({
            title : function() {
              return Drupal.t("This rubric score is used to calculate the question score");
            },
            gravity : "n"
          });

          if (scope.isComponent) {

            // Calculate rubric score ratio
            var rubric_score_ratio = (data.grade / scope.totalRubricPoints);

            // Apply rubric score ratio to question score
            var question_score = (rubric_score_ratio * maxPoints)
            if (data.grade == ''){
              questionPoints.text(' /' + maxPoints);
            } else {
              questionPoints.text(sGradesRoundNumber(question_score) + '/' + maxPoints);
            }

            // inject the score into the form
            score.val(rubric_score_ratio * maxPoints);

            // inject the rubric score into the form
            rubric_score.val(data.grade);

            // take into account 0
            if ($.isNumeric(data.grade)) {
              override.val('1');
            } else {
              // if the score is blank, clear the override
              override.val('0');
            }
          }

          // Interface with discussion page ajax grade form
          var discussionAjaxForm = rubricFakeInput.parents('form.grade-post-form:first');
          if(discussionAjaxForm.length > 0 && typeof sDiscussionAjaxPostMarkGraded == 'function'){
            var discUid = $('input.uid', discussionAjaxForm).val();
            sDiscussionAjaxPostMarkGraded(discUid);
          }
          // Interface with the dropbox submissions list
          var dropBoxGradeForm = rubricFakeInput.parents('#s-grade-item-edit-enrollment-grade-form:first');
          if (dropBoxGradeForm.length > 0) {
            if (data.grade > 0 && scope.textOnly) {
              sDropItemUpdateStudentDetails(dropBoxGradeForm, "<span class='inline-icon mini rubric-icon'></span>", 0);
            } else {
              sDropItemUpdateStudentDetails(dropBoxGradeForm, data.grade, 0);
            }
          }

          if (!scope.textOnly) {
            rubricFakeInput.text(data.grade);
          }
          $(document).trigger('gradingRubricTotalGradeUpdate', [element]);
        }
      });

      if (scope.isComponent){
        // trigger the grade update when loading assessment component grader to process the extra visuals
        var gradeValText = $('.rubric-fake-grade-disp .grade-val', element).text();
        var rubric_score = gradeValText;
        if ($.isNumeric(gradeValText)) {
          rubric_score = sGradesRoundNumber(gradeValText);
        }

        data = {
          enrollmentId: scope.enrollmentId,
          itemId: scope.itemId,
          rubricId: scope.rubricId,
          submissionId: scope.submissionId,
          grade: rubric_score,
          isDistrictMasteryGrading: false
        };
        sAngular.rootScopeBroadcast('gradingRubricTotalGradeUpdate', data);
      }

      element.click(function(){
        // Remove existing editor
        var existingEditor = $('#grading-rubric-edit-grades-slider');
        if (existingEditor.length == 0 && !scope.opened) {
          scope.opened = true;
          // Compile a new one
          var rubricOutput = Drupal.theme.s_grades_rubric_grading();
          Drupal.sAccessibility.setInitialFocusPopup($compile(rubricOutput)(scope).prependTo($('body')));
        }
        Drupal.sAccessibility.setLastFocus(element);
        sAngular.rootScopeBroadcast('gradingRubricGradesVars', {
          rubric_id : scope.rubricId,
          enrollment_id : scope.enrollmentId,
          item_id : scope.itemId,
          editable: scope.editable,
          isComponent: scope.isComponent,
          submissionId: scope.submissionId
        });
      });

      element.on('ReactInit', function(event, rubric, gradeInfo, overrideInfo, saveHandler, cancelHandler, readOnly){
        var existingEditor = $('#grading-rubric-edit-grades-slider');
        if (existingEditor.length == 0 && !scope.opened) {
          scope.opened = true;
          // Compile a new one
          var rubricOutput = Drupal.theme.s_grades_rubric_grading();
          Drupal.sAccessibility.setInitialFocusPopup($compile(rubricOutput)(scope).prependTo($('body')));
        }
        Drupal.sAccessibility.setLastFocus(element);
        sAngular.rootScopeBroadcast('ReactInit', {
          rubric: rubric,
          gradeInfo: gradeInfo,
          overrideInfo: overrideInfo,
          saveHandler: saveHandler,
          cancelHandler: cancelHandler,
          readOnly: readOnly
        });
      });
    }
  }
}]);

sAngular.addController('grading_rubric_edit_grades', ['$scope', 'gradingRubrics', function($scope, gradingRubrics){
  $scope.rubric = null;
  $scope.enrollmentId = null;
  $scope.itemId = null;
  $scope.gradeInfo = {};
  $scope.requiredLoads = []; // array to watch, when it is filled with everything needing loading we can remove ajax loader
  $scope.loadInProgress = false;
  $scope.state = 'opened';
  $scope.minimized = false;
  $scope.activeCommentBubbleRowId = false;
  $scope.gradeInfoDirty = false;
  $scope.overrideEditActive = false;
  $scope.manualOverride = false; // set when a user types a number into a rubric that is not equal to the score
  $scope.overrideCleared = false; // Keep a flag for when an override has been cleared out so we know something is dirty
  $scope.overrideInfo = {
    grade : null
  };

  $scope.trapTabKey = function(el, e) {
    Drupal.sAccessibility.trapTabKey(el, e);
  }

  $scope.toggleLoading = function(addOverlay){
    if(addOverlay){
      sToggleActiveLoader('grading-rubric-grading-panel', $('#grading-rubric-edit-grades-slider'));
    }
    else{
      sToggleActiveLoader('grading-rubric-grading-panel');
    }
  }

  // This is a utility function to check to see if it is even worth sending data to the server and triggering an angular grade save event
  $scope.hasInfoToSave = function(){
    if(!$scope.gradeInfoDirty){
      return false;
    }

    if($scope.gradeIsOverridden()){
      return true;
    }

    if($scope.overrideCleared){
      return true;
    }

    // Since grades are defaulted to empty strings, ensure that they have set something before saving (any of the grades is numeric)
    var hasValidGrade = false;
    $.each($scope.gradeInfo, function(i, gInfo){
      if($.isNumeric(gInfo.grade) || gInfo.comment != '' || (gInfo.grade == '' && angular.isUndefined(gInfo.initPlaceholder))){
        hasValidGrade = true;
        return false;
      }
    });
    return hasValidGrade;
  }

  $scope.$on('sEnrollmentChooserChange', function(event, newEnrollmentId, isDistrictMasteryGrading){
    if (isDistrictMasteryGrading) {
      return;
    }
    if($scope.enrollmentId == newEnrollmentId || $scope.rubric == null || $scope.isReactComponent){
      return;
    }
    if($scope.hasInfoToSave()){
      // Fire off a save request and hope for the best.  We are going to keep trucking and update the DOM anyway
      var gradingCategoryId = $scope.grading_category ? $scope.grading_category.id : undefined;
      gradingRubrics.saveRubricGradeInfo($scope.rubric.id, $scope.enrollmentId, $scope.itemId, $scope.gradeInfo, $scope.overrideInfo.grade, false, false, function(request, response){
        sAngular.rootScopeBroadcast('gradingRubricTotalGradeUpdateComplete', request, response);
      }, false, gradingCategoryId);
      $scope.rubricGradeUpdate($scope.rubric.id, $scope.enrollmentId, $scope.itemId, $scope.gradeInfo);
    }
    $scope.setRubricVars($scope.rubric.id, newEnrollmentId, $scope.itemId);
  })

  $scope.$on('gradingRubricGradesVars', function(event, data){
    if ($scope.isReactComponent === true) {
      return;
    }
    var rubricId = data.rubric_id;
    var enrollmentId = data.enrollment_id;
    var itemId = data.item_id;
    var readOnly = !data.editable;
    var isComponent = data.isComponent;
    var submissionId = data.submissionId;
    $scope.setRubricVars(rubricId, enrollmentId, itemId, readOnly, isComponent, submissionId);
  });
  
  $scope.$on('ReactInit', function(event, data){
    $scope.isReactComponent = true;
    $scope.rubric = data.rubric;
    $scope.gradeInfo = data.gradeInfo;
    $scope.overrideInfo = data.overrideInfo;
    $scope.saveHandler = data.saveHandler;
    $scope.cancelHandler = data.cancelHandler;
    $scope.gradeInfoDirty = false; // always clean on init
    $scope.readOnly = data.readOnly;
    $scope.changeState('opened');
  });

  $scope.setRubricVars = function(rubricId, enrollmentId, itemId, readOnly, isComponent, submissionId){
    if ($scope.isReactComponent === true) {
      return;
    }
    if($scope.loadInProgress){
      return;
    }
    $scope.loadInProgress = true;
    $scope.enrollmentId = enrollmentId;
    $scope.itemId = itemId;
    $scope.gradeInfo = {}; // Reset grade info for the launch
    $scope.readOnly = readOnly;
    $scope.isComponent = isComponent;
    $scope.submissionId = submissionId;

    gradingRubrics.getRubricById(rubricId, function(rubric){
      $scope.rubric = angular.copy(rubric);
      $scope.requiredLoads.push('rubric');
    });
    gradingRubrics.loadRubricGradeInfo(rubricId, enrollmentId, itemId, isComponent, submissionId, function (body) {
      $scope.gradeInfo = body.gradeInfo;
      $scope.overrideInfo.grade = body.overrideGrade;
      $scope.overrideEditActive = true;
      $scope.toggleOverrideEdit();
      $scope.requiredLoads.push('gradeInfo');
    });

    $scope.toggleLoading(true);
    // Add the loader when this is opened
    $scope.changeState('opened');
  }

  $scope.canEditGrade = function(){
    return !$scope.readOnly;
  }


  // Bind click on document so if user clicks anywhere but bubble we can remove bubble
  $(document).click(function(e){
    var evTarget = $(e.target);
    var commentBubbleClick = evTarget.hasClass('inline-popup-wrapper') || evTarget.hasClass('active-comment-bubble') || evTarget.parents('.inline-popup-wrapper').length > 0;
    if($scope.activeCommentBubbleRowId == false || commentBubbleClick){
      return;
    }
    $scope.setActiveCommentBubble(false);
    if(!$scope.$$phase){
      $scope.$apply();
    }
  });

  $scope.setActiveCommentBubble = function(rowId, event){
    if ($scope.activeCommentBubbleRowId == rowId){
      return;
    }
    $scope.activeCommentBubbleRowId = rowId;
    if(typeof event != 'undefined'){
      event.stopPropagation();
      event.preventDefault();
    }
    if(rowId != false){
      var bubbleObj = $('#comment-area-' + rowId);
      var plObj = $('#rubric-grading-row-area-' + rowId);
      var plPos = plObj.position();
      var newTop = plPos.top + 38;
      var newLeft = plPos.left - 10;
      bubbleObj.offset({top : newTop});
    }
    return false;

  }
  $scope.$watch('gradeInfo', function(newVal, oldVal){
    if(angular.isArray(newVal)){ // Sometimes when this is initialized as an empty object, angular is turning it into an empty array - Make sure it is object
      $scope.gradeInfo = {};
    }
    if ($scope.isReactComponent === true) {
      // for react component, ensure that there is always an object for every rubric row in gradeInfo
      if (typeof($scope.gradeInfo) != 'object'){
        $scope.gradeInfo = {};
      }
      $.each($scope.rubric.rows, function(idx, obj){
        if (angular.isUndefined($scope.gradeInfo[obj.id])) {
          $scope.gradeInfo[obj.id] = {
            comment: '',
            grade: null,
          };
        }
      });
    }
    $scope.gradeInfoDirty = true;
  },true)

  $scope.$watch('overrideInfo.grade', function(newVal, oldVal){
    $scope.gradeInfoDirty = true;
  })

  // Watch for when both ajax loads are complete
  $scope.$watch('requiredLoads', function(newVal, oldVal){
    if ($scope.isReactComponent === true) {
      return;
    }
    if($.inArray('rubric', newVal) !== -1 && $.inArray('gradeInfo', newVal) !== -1){
      $scope.toggleLoading();
      $scope.loadInProgress = false;
      // Place default values in gradeInfo if no grades or incomplete grades
      if(!angular.isObject($scope.gradeInfo)){
        $scope.gradeInfo = {};
      }
      $.each($scope.rubric.rows, function(i, row){
        if(angular.isUndefined($scope.gradeInfo[row.id])){
          var objAttr = row.id.toString();
          // Make sure to always cast as string so JS does not thing this should be an array
          $scope.gradeInfo[objAttr] = {
            grade : '',
            comment : '',
            initPlaceholder : true // When we are deciding whether to save grades, we want to indicate that this grade was filled in by us and maybe shouldn't be saved to server
          }
        }
      });
      // we just possibly dirtied our dirty flag so set it back to false
      $scope.gradeInfoDirty = false;
      sAngular.rootScopeBroadcast('sEnrollmentChooserChangeValue', $scope.enrollmentId);
      $scope.requiredLoads = [];// Empty out required loads in anticipation of next load
      sGradesResizeInnerTable($('.rubric-grades-edit'));

    }
  }, true);

  $scope.$on('sEnrollmentChooserLoadComplete', function(isDistrictMasteryGrading){
    if (isDistrictMasteryGrading) {
      return;
    }
    if ($scope.isReactComponent === true) {
      return;
    }
    if($scope.enrollmentId != null){
      sAngular.rootScopeBroadcast('sEnrollmentChooserChangeValue', $scope.enrollmentId);
    }
  });

  $scope.toggleOverrideEdit = function(){
    if(!$scope.canEditGrade()){
      return;
    }

    if($scope.overrideEditActive == false){
      $scope.overrideEditActive = true;
      if(!$scope.gradeIsOverridden()){
        $scope.overrideInfo.grade = $scope.calculatedTotalPoints();
      }
      if(!$scope.$$phase){
        $scope.$apply();
      }
    }
    else{
      $scope.overrideEditActive = false;
      $scope.manualOverride = true;
      if(!$scope.gradeIsOverridden()){
        $scope.overrideInfo.grade = null;
        $scope.manualOverride = false;
      }
      if(!$scope.$$phase){
        setTimeout($scope.$apply.bind($scope), 0);
      }
    }
  }

  $scope.clearGradeOverride = function(){
    $scope.overrideInfo.grade = null;
    $scope.overrideCleared = true;
  }

  $scope.calculatedTotalPoints = function(){
    var gradesTotal = null;
    if($scope.rubric == null || $scope.gradeInfo == null){
      return;
    }
    $.each($scope.gradeInfo, function(i, info){
      if(info.grade != null && info.grade != ''){
        gradesTotal = gradesTotal == null ? 0 : gradesTotal;
        gradesTotal += sGradesRoundNumber(info.grade);
      }
    });
    gradesTotal = $.isNumeric(gradesTotal) ? sGradesRoundNumber(gradesTotal) : gradesTotal;

    return gradesTotal;
  }

  $scope.totalPoints = function(){
    if($scope.rubric == null){
      return;
    }
    if($scope.gradeIsOverridden()){
      return $scope.overrideInfo.grade;
    }
    var gradesTotal = $scope.calculatedTotalPoints();
    if (gradesTotal === null){
      return '';
    }
    return gradesTotal;
  };

  $scope.gradeOverrideError = function(){
    // Do not allow empty string or non-numeric value as an override
    if ($scope.overrideInfo.grade === '' || ($scope.overrideInfo.grade !== null && !$.isNumeric($scope.overrideInfo.grade))) {
      return true;
    }
    
    return false;
  }

  $scope.gradeIsOverridden = function(){
    if((!$scope.manualOverride && $scope.isComponent) || typeof $scope.overrideInfo.grade == 'undefined' || $scope.overrideInfo.grade == null || $scope.gradeOverrideError()){
      return false;
    }

    return $scope.calculatedTotalPoints() !== $scope.overrideInfo.grade;
  }

  $scope.changeState = function(newState){
    var oldState = $scope.state;
    if(oldState == 'slide-closed' && newState == 'slide-closed'){
      newState = 'opened';
    }
    $scope.state = newState;
    if ($scope.isReactComponent === true && $scope.state === 'closed') {
      $scope.cancelHandler();
      return;
    }
    sAngular.rootScopeBroadcast('sEnrollmentChooserClose');
  };

  $scope.getState = function(){
    return $scope.state;
  }

  $scope.getBubbleIconClass = function(rowId){
    if(angular.isUndefined($scope.gradeInfo[rowId])){
      return '';
    }
    var classStr = '';
    if($scope.gradeInfo[rowId].comment.length > 0){
      classStr += ' hasComment';
    }
    if($scope.activeCommentBubbleRowId == rowId){
      classStr += ' active';
    }
    return classStr;
  }

  $scope.rubricGradesBodyClass = function(){
    var classStr = $scope.state;
    if($scope.state == 'closed'){
      classStr += ' hidden';
    }
    if($scope.readOnly){
      classStr += ' view-only';
    }
    classStr += $scope.minimized ? ' minimized' : '';
    return classStr;
  }

  $scope.minimize = function(){
    $scope.minimized = !$scope.minimized;
  }

  $scope.isMinimized = function(){
    return $scope.minimized;
  }

  $scope.ratingSelect = function(rowId, points){
    // If this is a react component, check that gradeInfo has been defined    
    if ($scope.isReactComponent && angular.isUndefined($scope.gradeInfo[rowId.toString()])) {
      $scope.gradeInfo[rowId.toString()] = {
        grade: null,
        comment: '',
      }
    }
    // Make sure to cast as string so JS does not think this is array
    $scope.gradeInfo[rowId.toString()].grade = $scope.gradeInfo[rowId.toString()].grade == points ? '' : points;
  }

  $scope.rubricGradeFormSubmit = function(isSubmit){
    if ($scope.isReactComponent === true) {
      if(isSubmit && $scope.hasInfoToSave()){
        $scope.saveHandler($scope.gradeInfo, $scope.overrideInfo);
      } else {
        $scope.cancelHandler();
      }
      $scope.changeState('closed');
      return;
    }

    if(isSubmit){
      if($scope.loadInProgress){
        return;
      }
      if(!$scope.hasInfoToSave()){
        $scope.changeState('closed');
        return;
      }
      $scope.loadInProgress = true;
      $scope.toggleLoading(true);
      sAngular.rootScopeBroadcast('gradingRubricTotalGradeUpdateSubmit', {
        itemId : $scope.itemId,
        enrollmentId : $scope.enrollmentId,
        rubricId : $scope.rubric.id,
        gradeInfo : $scope.gradeInfo
      });
      // get submission comment
      questionReviewObj = $('[rubric-id="' + $scope.rubricId + '"][enrollment-id="' + $scope.enrollmentId + '"][submission-id="' + $scope.submissionId + '"]').parents('.question-review').eq(0);
      comment = $('.question-comment-wrapper textarea', questionReviewObj).val()
      var gradingCategoryId = $scope.grading_category ? $scope.grading_category.id : undefined;
      gradingRubrics.saveRubricGradeInfo($scope.rubric.id, $scope.enrollmentId, $scope.itemId, $scope.gradeInfo, $scope.overrideInfo.grade, $scope.isComponent, $scope.submissionId, function(request, response){
        $scope.rubricGradeUpdate($scope.rubric.id, $scope.enrollmentId, $scope.itemId, $scope.gradeInfo, $scope.submissionId);
        $scope.toggleLoading();
        $scope.loadInProgress = false;
        $scope.overrideCleared = false;
        $scope.changeState('closed');
        sAngular.rootScopeBroadcast('gradingRubricTotalGradeUpdateComplete', request, response);
      }, comment, gradingCategoryId)
    }
    else{
      $scope.changeState('closed');
    }
  }

  $scope.rubricGradeUpdate = function(rubricId, enrollmentId, itemId, gradeInfo, submissionId){
    if ($scope.isReactComponent === true) {
      return;
    }
    var newGrade = '';
    $.each(gradeInfo, function(rowId, data){
      if(data.grade != ''){
        newGrade = newGrade == '' ? 0 : newGrade;
        newGrade += sGradesRoundNumber(data.grade);
      }
    })
    newGrade = $scope.totalPoints();
    var eventData = {
      itemId : itemId,
      enrollmentId : enrollmentId,
      rubricId : rubricId,
      grade : newGrade,
      submissionId : submissionId,
      isDistrictMasteryGrading: false
    };
    sAngular.rootScopeBroadcast('gradingRubricTotalGradeUpdate', eventData);
  }

}]);

function sGradesResizeInnerTable(context){
  $('.rubric-row', context).each(function(){
    var rowHeight = $(this).height();
    $('.rubric-row-rating table td .rating-item', $(this)).css('min-height', rowHeight - 1);
  })
}

function sGradesRoundNumber(val){
  if(!$.isNumeric(val)){
    return 0;
  }

  return (Math.round(parseFloat(val) * 100) / 100);
}

// trap the tab key inside the popup
sAngular.addDirective('sJsTab', function() {
  return function(scope, element, attrs) {
    element.bind('keydown', function(e){
      if(e.which === 9) {
        if(typeof scope[attrs.sJsTab] === 'function') {
          scope.$apply(function() {
            scope[attrs.sJsTab](element, e);
          });
        }
      }
    });
  };
});

// set the focus to the first tabable item when opened
sAngular.addDirective('sJsManageFocus', function(){
  return {
    restrict : 'C', // bind this behavior to the s-js-manage-focus class name
    link: function(scope, element, attrs) {
      scope.$watch('state', function(newState, oldState) {
        if(newState === 'opened' && oldState === 'closed') { // check specifically for opened and closed (to avoid resetting on slide-open and slide-closed)
          Drupal.sAccessibility.setInitialFocusPopup(element);
          Drupal.sAccessibility.revealToAT(element);
          Drupal.sAccessibility.hideFromAT($('#body'));
        } else if(newState === 'opened') {
          Drupal.sAccessibility.revealToAT(element);
          Drupal.sAccessibility.hideFromAT($('#body'));
        } else if(newState === 'closed') { // return focus to original item when the popup is closed
          Drupal.sAccessibility.returnFocus();
          Drupal.sAccessibility.hideFromAT(element);
          Drupal.sAccessibility.revealToAT($('#body'));
        }
      });
    }
  }
});
;// JavaScript Document
var wait_image = '/sites/all/themes/schoology_theme/images/ajax-loader.gif';
var wait_image_width = 43;
var wait_image_height = 11;

Drupal.behaviors.sGradeItem = function(context){
	sGradeItemEnableCommentJump();

	// cluetip
  if($('#save-for-later-help', context).length){
	 $('#save-for-later-help', context).cluetip({splitTitle: '|', dropShadow: false, showTitle: false, positionBy: 'auto'});
  }

	$('.grade-item-action-links:not(.sGradeItem-processed)', context).addClass('sGradeItem-processed').each(function () {
		$(this).sActionLinks({hidden: false,	wrapper: '.action-links-wrapper'});
	});

	$('.info-container .view-info:not(.sGradeItem-processed)', context).addClass('sGradeItem-processed').each(function () {
		var linkBtn = $(this);
		linkBtn.bind('click', function(){
			var wrapper = $(this).parent();
			$('.grading-info', wrapper).toggle();
			linkBtn.toggleClass('active');
			return false;
		}).tipsy({
      'gravity': 'se'
    });
	});
	$('body').unbind('click.sGradeViewInfo').bind('click.sGradeViewInfo', function(e){
	  var linkBtn = $('.info-container .view-info', context);
	  var target = $(e.target);
	  if(linkBtn.hasClass('active') && target.not('.grading-info') && target.parents('.grading-info').length == 0){
	    linkBtn.click();
	  }
	});

	$('.info-container .link-btn:not(.sGradeItem-processed)', context).addClass('sGradeItem-processed').each(function () {
	  $(this).tipsy({
	    'gravity': 'se'
	  });
	});


	$('.comment:not(.sGradeItem-processed)', context).addClass('sGradeItem-processed').each(function () {
    	var comment = $(this);
			comment.bind('mouseenter', function(){
					$(".entry-links-view", comment).show();
			}).bind('mouseleave', function(){
				  $(".entry-links-view", comment).hide();
			});
	});

  if(typeof tinyMCE != 'undefined'){
    // the comment input usually initialize when the user focuses on the textarea
    // since there are many of these on the homepage
    // but the one on the assignment and assessment page can be initialized on page load since there is only one of them
    $('.s_grade_item_assignment #edit-comment.s-tinymce-load-editor:not(.sGradeItem-processed), .s_grade_item_assessment #edit-comment.s-tinymce-load-editor:not(.sGradeItem-processed)', context).addClass('sDiscussion-sGradeItem').each(function(){
      var textareaObj = $(this),
          id = textareaObj.attr('id'),
          editor = tinyMCE.get(id);
      if(!editor){
        sTinymceInit({
          elements: id,
          toolbar: 'basic_comment'
        });
      }
    });
  }

	$('#s-grade-item-add-attachment-form:not(.sGradeItem-processed)', context).addClass('sGradeItem-processed').each(function() {
		setTimeout(function(){
			$('#file-selector').click();
		},150);
	});

  var commentVal = "";
  $(".comment-area-toggle").on("click", function () {
    commentVal = $("#edit-comment-wrapper .title-infield").val();
  });

  $(".grade-submit-buttons .cancel-btn").on("click", function (el) {
    $("#edit-comment-wrapper .title-infield").val(commentVal);
    $(el.currentTarget).closest("#s-grade-item-edit-enrollment-grade-form").removeClass("active");
  });

  if ($('body').hasClass('s-enable-mathml')) {
    s_renderMath();
  }

  $('body:not(.sGradeItem-processed)', context).addClass('sGradeItem-processed').each(function() {
    var viewInfoClickHandlers;
    var viewStatsClickHandlers;

    $(this).on('grade-item-disable-top-controls', function() {
      $('.grade-item-action-links .action-links-unfold', context).addClass('disabled');

      var viewInfoLink = $('.link-btn.view-info', context);
      if (viewInfoLink.length) {
        if (viewInfoLink.data('events')) {
          viewInfoClickHandlers = viewInfoLink.data('events').click;
          viewInfoLink.data('events').click = null;
        }
        viewInfoLink.addClass('disabled');
        viewInfoLink.tipsy('disable');
      }

      var viewStatsLink = $('.link-btn.view-stats', context);
      if (viewStatsLink.length) {
        if (viewStatsLink.data('events')) {
          viewStatsClickHandlers = viewStatsLink.data('events').click;
          viewStatsLink.data('events').click = null;
        }

        viewStatsLink.addClass('disabled');
        viewStatsLink.tipsy('disable');
        viewStatsLink.click(function(e) { e.preventDefault(); });
      }

      $('.assessment-status-wrapper', context).addClass('disabled');
    });

    $(this).on('grade-item-enable-top-controls', function() {
      $('.grade-item-action-links .action-links-unfold', context).removeClass('disabled');

      var viewInfoLink = $('.link-btn.view-info', context);
      if (viewInfoLink.length) {
        viewInfoLink.removeClass('disabled').tipsy('enable');
        if (viewInfoLink.data('events')) {
          viewInfoLink.data('events').click = viewInfoClickHandlers;
        }
      }

      var viewStatsLink = $('.link-btn.view-stats', context);
      if (viewStatsLink.length) {
        viewStatsLink.removeClass('disabled').tipsy('enable');
        if (viewStatsLink.data('events')) {
          viewStatsLink.data('events').click = viewStatsClickHandlers;
        }
      }

      $('.assessment-status-wrapper', context).removeClass('disabled');
    });
  });
};

function sGradeItemEnableCommentJump(){

	$(".go-to-reply").click(function() {
    var el = $(this).parent().parent().parent().parent();
		if (location.pathname.replace(/^\//,'') == this.pathname.replace(/^\//,'') && location.hostname == this.hostname) {
      var target = $(this.hash);
			$(target).effect("highlight", {color: "#f9b974"}, 3000);
      target = target.length && target || $('[name=' + this.hash.slice(1) +']');
      if (target.length) {
        var targetOffset = target.offset().top-20;
        $('html,body').animate({scrollTop: targetOffset}, 500);
       return false;
      }
    }
  });
}

/**
 * Ajax plugins callback
 *
 * @param {String} hook
 * @param {Object} args
 * @return {Bool}
 */

Drupal.Ajax.plugins.s_grade_item = function(hook, args) {
  if(hook == 'message') { // response received, return false to hide messages
    var submitter = args.local.submitter;
        formObj = submitter.closest('.post-comment-form');

    if(formObj.length){
      if(typeof args.redirect == 'string' && args.redirect.length > 0){
        window.location.href = args.redirect;
      }
      else{
        var validateOutput = args.ajax_validate_output;
        var submitOutput = args.ajax_submit_output;

        var id = 'comment-container';
        var content = '';
        // Display the submit output if set, otherwise display validate output
        if(submitOutput != undefined)
          content = submitOutput;
        else if(validateOutput != undefined)
          content = validateOutput;

        if($("."+id+" #s_comments").length > 0){ //append to existing comment wrapper
          $("."+id+" #s_comments").fadeIn(5000, function(){
            var contentObj = $(content);
            $("."+id+" #s_comments").append(contentObj);
            Drupal.attachBehaviors(contentObj);
          });
        }
        else{ //create own comment wrapper
          var html = '<div id="s_comments">'+content+'</div>';
          var contentObj = $(html);
          $(".no-comments").replaceWith(contentObj);
          Drupal.attachBehaviors(contentObj);
        }
        var editorObj = formObj.find('.s-tinymce-load-editor');
        if(editorObj.length){
          var ed = tinyMCE.get(editorObj.attr('id'));
          if(ed){
            ed.setContent('');
            ed.save();
          }
        }
        return false;
      }
    }
  }
  return false;
}
;
var wait_image = '/sites/all/themes/schoology_theme/images/ajax-loader.gif';
var wait_image_width = 43;
var wait_image_height = 11;

/**
 * Ajax plugins callback
 *
 * @param {String} hook
 * @param {Object} args
 * @return {Bool}
 */
Drupal.Ajax.plugins.s_comment = function(hook, args) {

  switch( hook ) {
    case 'submit':
      var submitter = args.submitter,
          formObj = submitter.closest('form'),
          editorObj = formObj.find('.s-tinymce-load-editor');
      if(formObj.hasClass('post-comment-form')){
        submitter.attr('disabled', 'disabled').parent().addClass('disabled');
      }
      if(editorObj.length){
        var ed = tinyMCE.get(editorObj.attr('id'));
        if(ed){
          ed.save();
        }
      }
    break;

    case 'message':
      var submitter = args.local.submitter;
      var commentForm = submitter.parents('form');
      if(!submitter.parents('form').hasClass('post-comment-form')){
        return;
      }

      // reenable the submit button if the form's disable_submit flag is set to FALSE
      var submitEnabledForm = (submitter.parents('.submit-enabled').length > 0);
      if(submitEnabledForm){
      	submitter.attr('disabled', false).parent().removeClass('disabled');
      }

      var validateOutput = args.ajax_validate_output;
      var submitOutput;
      var allComments;
      if(typeof(args.ajax_submit_output) == 'object') {
        submitOutput = args.ajax_submit_output.newComment;
        allComments = args.ajax_submit_output.allComments;
      }
      else {
        submitOutput = args.ajax_submit_output;
      }
      var footerComments = submitter.closest(":has(.feed-comments, .blog-comments, .discussion-content, .album-comments, .update-comments)")
          .find('.feed-comments, .blog-comments, .discussion-content, .album-comments, .update-comments');
      var feedContent = footerComments.parent();
      var content = '';
      var isDiscussion = $('body').hasClass('discussion-view');

      // Display the submit output if set, otherwise display validate output
      if(submitOutput != undefined)
        content = submitOutput;
      else if(validateOutput != undefined)
        content = validateOutput;

      // discussion comments, hide the 'no comments' message
      $("p.no-discussion",$(".discussion-content")).hide()

      //Post comment gets added to end of discussion thread in this block
      if(footerComments.find("#s_comments").length > 0) {
        footerComments.find("#s_comments").fadeIn(5000, function(){
          var contentObj = $("<div class='discussion-card'></div>");
          contentObj.append(content);

          if(isDiscussion) {
            $(this).prepend(contentObj);
          } else {
            $(this).append(contentObj);
          }
          Drupal.attachBehaviors(contentObj);
          // submission failed (ie, discussion is locked)
          var is_locked = false;
          for (i = 0; i < args.messages_error.length; ++i) {
            if(args.messages_error[i].value == 'This discussion is locked') {
              is_locked = true;
            }
          }
          if(is_locked) {
            footerComments.find("textarea")
              .attr('defaulttext', footerComments.find("textarea").val())
              .addClass('is-locked');
          }
          sCommentScrollToNewComment(contentObj, 750, ":has(.s-comments-post-form-new)");
          if(isDiscussion){
            var colorString = "rgba(213,227, 241, 0.6)";
            contentObj.effect("highlight", {color: colorString}, 3000);
          }
        });
      }
      else {
        var contentObj = $('<div id="s_comments"><div class="discussion-card">'+content+'</div></div>');
        if(isDiscussion){
          var colorString = "rgba(213,227, 241, 0.6)";
          footerComments.find(".s-comments-post-form").after(contentObj);
          contentObj.effect("highlight", {color: colorString}, 3000);
        } else {
          footerComments.find(".s-comments-post-form").before(contentObj);
        }
        Drupal.attachBehaviors(contentObj);
      }

      // clear the user input
      var inputObj = commentForm.find('textarea');
      if(inputObj.length){
        if(inputObj.hasClass('s-tinymce-load-editor')){
          var ed = tinyMCE.get(inputObj.attr('id'));
          if(ed){
            ed.setContent('');
            ed.save();
          }
        }
        else{
          inputObj.val('').trigger('blur');
        }
      }
           
      // show all comments; remove disabled classes
      // activate stats filter
      if(allComments) {
        for(var cid in allComments) {
          var commentWrapper = footerComments.find("#comment-" + cid);
          var commentBodyWrapper = $(".comment-body-wrapper", commentWrapper);
          var commentTopWrapper = $(".comment-top", commentWrapper);
          commentBodyWrapper.removeClass('disabled');

          // The html is encoded because of check_plain, so we need to decode it.
          // Textarea is used since no html elements are allowed in a textarea, making it safer against XSS.
          // If there happens to be html elements, it will be encoded by the browser.
          var commentBody = $('<textarea/>').html(allComments[cid].body).val();
          commentBodyWrapper.html(commentBody);
          $(allComments[cid].attachments).insertAfter(commentTopWrapper);
          commentWrapper.removeClass('disabled');
          $(".comment-reply", commentWrapper).removeClass('disabled').show();
        }
        Drupal.attachBehaviors(footerComments);
        footerComments.prev('.discussion-require-post-notice').remove();
        var courseInfo = footerComments.parents('.course-discussion');
        $('#discussion-user-stats-wrapper', courseInfo).removeClass('disabled');
        sAttachBehaviors(['s_discussion'], courseInfo);
      }
      
      // for update commment popup, resize and center
      if( footerComments.hasClass('update-comments') ){
        popup = Popups.activePopup();
        if(popup) Popups.resizeAndCenter(popup);
      }

      var numCommentsLink = feedContent.find(".feed-footer").find("span.ajax-post-comment");
      var text = numCommentsLink.text();
      var splice = text.split(" ");
      var comments = splice[0];
      var suffix = splice[1];

      if(comments == 1)
        suffix = splice[1]+"s";

      ++comments;
      numCommentsLink.text(comments+ " "+suffix);     
      //resize textarea back to default size of 32 pixels
      $('#edit-comment-wrapper #edit-comment', commentForm).css('height', '32px');     
    break;

    case 'afterMessage':
      // reset attachment form
      if(!args.ajax_submit_output)
        return;
      
      if ($('#attachments').length > 0){
        resetAttachmentForm();    
        
        //reset basic attachment form
        sAttachmentResetBasicUploader();
        
        //in certain areas (school updates, course/group discussions) need to adjust DOM when using the basic uploader
        unWantedForm = $('#edit-file-swf-wrapper .upload-form');
        if (unWantedForm){
          $('#edit-file-swf-wrapper').append(unWantedForm.children('input'));
          unWantedForm.remove();
        }
      }

      if ($('li#file-selector').hasClass('active')){
        $('li#file-selector').removeClass('active');
      }

      break;
  }
}

;// JavaScript Document

var wait_image = '/sites/all/themes/schoology_theme/images/ajax-loader.gif';
var wait_image_width = 43;
var wait_image_height = 11;

/**
 * Ajax plugins callback
 *
 * @param {String} hook
 * @param {Object} args
 * @return {Bool}
 */
Drupal.Ajax.plugins.s_comment_reply = function(hook, args) {
  switch(hook){
    case 'submit': // submitting the form
      // disable the submit button
      var submitter = args.submitter;
      submitter.attr('disabled', 'disabled').parent().addClass('disabled');
      break;
    case 'message': // response received, return false to hide messages
      var submitter = args.local.submitter;
      var form = submitter.parents('form');
      if(form.attr('id') == 's-comment-reply-form'){
        if(typeof args.redirect == 'string' && args.redirect.length > 0){
          window.location.href = args.redirect;
        }
        else{
          // reenable the submit button
          submitter.attr('disabled', false).parent().removeClass('disabled');

          var validateOutput = args.ajax_validate_output;
          var submitOutput = args.ajax_submit_output;

          var content = '';
          // Display the submit output if set, otherwise display validate output
          if(submitOutput != undefined){
            // clear the rich text or input text area
            var inputObj = form.find('textarea');
            if(inputObj.length){
              if(inputObj.hasClass('s-tinymce-load-editor')){
                var ed = tinyMCE.get(inputObj.attr('id'));
                if(ed){
                  ed.setContent('');
                  ed.save();
                }
              }
              else{
                inputObj.val('').trigger('blur');
              }
            }

            content = submitOutput;

            var parentComment = submitter.parents('.comment').eq(0);
            var replyLevel = parentComment.next('.s_comments_level');
            // if the next level of replies does not yet exist, create it
            if(replyLevel.length == 0){
              replyLevel = $('<div class="s_comments_level"></div>');

              // Add nested class if needed
              var parentCommentLevel = parentComment.parent('.s_comments_level');
              if(parentCommentLevel && parentCommentLevel.hasClass('nested-threshold-exceeded')) {
                replyLevel.addClass('nested-threshold-exceeded');
              }

              parentComment.after(replyLevel);
            }
            var newComment = $(content);
            replyLevel.append(newComment);
            form.parent().hide();

            // Discussion only behavior
            var isDiscussion = $('body').hasClass('discussion-view');
            var colorString = "#f9b974";
            sCommentScrollToNewComment(newComment, 500);
            if(isDiscussion){
              colorString = "rgba(213,227, 241, 0.6)";
            }
            newComment.effect("highlight", {color: colorString}, 3000);

            Drupal.attachBehaviors(replyLevel);
          } else if(validateOutput != undefined) {
            content = validateOutput;
          }

          //increment the thread counter and show the hide link if exists
          var threadRoot = submitter.closest('.thread-root');
          var expanderBar = threadRoot.prev();
          //ensure its not a pending comment
          var contentObj = $(content);
          var isPending = $('.pending-comment', contentObj).length > 0;
          if(expanderBar.hasClass('expander-bar') && !isPending){
            var numRepliesWrapper = $('.num-replies', expanderBar);
            var numReplies = numRepliesWrapper.text();
            var expandText = $('.expander-text', expanderBar);
            var hideText = $('.expander-hide-text', expanderBar);
            numReplies = parseInt(numReplies);
            numReplies++;
            numRepliesWrapper.html(numReplies);
            expandText.html(Drupal.formatPlural(numReplies, '1 Reply', '@count Replies'));
            hideText.html(Drupal.formatPlural(numReplies, 'Hide 1 reply', 'Hide All @count Replies'));
            if (numReplies == 1) {
              $('.expander-link-expanded', expanderBar).removeClass('hidden');
            }
          }
        }
      }
      break;
  }
}
;